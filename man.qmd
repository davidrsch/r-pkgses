# Documentación de la función {#sec-man}

```{r, echo = FALSE}
source("common.R")
```

En este capítulo, aprenderá sobre la documentación de funciones, a la que los usuarios acceden con `?algunafunción` o `help("algunafunción")`.
Base R proporciona una forma estándar de documentar un paquete donde cada función está documentada en un **tema**, un archivo `.Rd` ("documentación R") en el directorio `man/`.
Los archivos `.Rd` utilizan una sintaxis personalizada, basada libremente en LaTeX, y se pueden representar en HTML, texto sin formato o pdf, según sea necesario, para verlos en diferentes contextos.

En el ecosistema devtools, no editamos archivos `.Rd` directamente con nuestras propias manos.
En su lugar, incluimos "comentarios de roxygen" con formato especial encima del código fuente para cada función[^man-1].
Luego usamos el [paquete roxygen2](https://roxygen2.r-lib.org/index.html) para generar los archivos `.Rd` a partir de estos comentarios especiales[^man-2]
. Hay algunas ventajas al usar roxygen2
:

[^man-1]: El nombre "roxygen" es un guiño al generador de documentación Doxygen, que inspiró el desarrollo de un paquete R llamado roxygen.
    Luego, ese concepto original se reinició como roxygen2, similar a ggplot2.

[^man-2]: El archivo NAMESPACE también se genera a partir de estos comentarios de roxygen.
    O, mejor dicho, *puede* serlo y ese es el flujo de trabajo preferido de devtools (@sec-dependencies-NAMESPACE-workflow).

-   El código y la documentación están ubicados en el mismo lugar.
    Cuando modifica su código, es fácil recordar que también debe actualizar su documentación.

-   Puede utilizar Markdown, en lugar de tener que aprender un lenguaje de marcado único que sólo se aplica a archivos `.Rd`.
    Además del formato, la función de hipervínculos automáticos hace que sea mucho más fácil crear documentación con muchos enlaces.

-   Hay una gran cantidad de texto estándar `.Rd` que está automatizado.

-   roxygen2 proporciona una serie de herramientas para compartir contenido entre temas de documentación e incluso entre temas y viñetas.

En este capítulo nos centraremos en documentar funciones, pero las mismas ideas se aplican a documentar conjuntos de datos (@sec-documenting-data), clases, genéricos y paquetes.
Puede obtener más información sobre esos temas importantes en `vignette("rd-other", package = "roxygen2")`.

## conceptos básicos de roxygen2

Para comenzar, analizaremos el flujo de trabajo básico de roxygen2 y analizaremos la estructura general de los comentarios de roxygen2, que están organizados en bloques y etiquetas.
También destacamos las mayores ventajas de utilizar Markdown con roxygen2.

### El flujo de trabajo de documentación {#sec-man-workflow}

A diferencia de testthat, no hay un movimiento de apertura obvio para declarar que vas a utilizar roxygen2 para la documentación.
Esto se debe a que el uso de roxygen2 es puramente una cuestión de su flujo de trabajo de desarrollo.
No tiene ningún efecto, por ejemplo, sobre cómo se comprueba o construye un paquete.
Creemos que el enfoque de roxygen es la mejor manera de generar archivos `.Rd`, pero oficialmente R solo se preocupa por los archivos en sí, no por cómo surgieron.

Su flujo de trabajo de documentación realmente comienza cuando comienza a agregar comentarios de roxygen encima de sus funciones.
Las líneas de comentarios de Roxygen siempre comienzan con `#'`, el `#` habitual para un comentario, seguido inmediatamente por una comilla simple `'`:

```{r}
#' Suma dos números
#' 
#' @param x Un número.
#' @param y Un número.
#' @returns Un vector numéro.
#' @examples
#' add(1, 1)
#' add(10, 1)
add <- function(x, y) {
  x + y
}
```

::: callout-tip
## RStudio

Por lo general, primero escribe su función y luego su documentación.
Una vez que exista la definición de la función, coloque el cursor en algún lugar de ella y haga *Código \> Insertar esqueleto de Roxygen* para obtener una gran ventaja en el comentario de roxygen.
:::

Una vez que tenga al menos un comentario de roxygen, ejecute `devtools::document()` para generar (o actualizar) los archivos `.Rd` de su paquete[^man-3].
En el fondo, esto finalmente se llama `roxygen2::roxygenise()`. El bloque roxygen anterior genera un archivo `man/add.Rd` que se ve así:

[^man-3]: La ejecución de `devtools::document()` también afecta a otro campo en `DESCRIPTION`, que se ve así: `RoxygenNote: 7.2.1`.
    Esto registra qué versión de roxygen2 se usó por última vez en un paquete, lo que facilita que devtools (y sus paquetes subyacentes) hagan una suposición inteligente sobre cuándo volver a `document()` un paquete y cuándo dejarlo en paz.
    En un entorno colaborativo, esto también reduce los cambios molestos en los archivos `.Rd`, al hacer que la versión relevante de roxygen2 sea muy visible.

``` text
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add.R
\name{add}
\alias{add}
\title{Suma dos números}
\usage{
add(x, y)
}
\arguments{
\item{x}{Un número.}

\item{y}{Un número.}
}
\value{
Un vector numéro.
}
\description{
Suma dos números
}
\examples{
add(1, 1)
add(10, 1)
}
```

::: callout-tip
## RStudio

También puede ejecutar `devtools::document()` con el método abreviado de teclado Ctrl/Cmd + Shift + D o mediante el menú o panel *Construir*.
:::

Si ha usado LaTeX antes, esto debería resultarle vagamente familiar ya que el formato `.Rd` se basa libremente en LaTeX.
Si está interesado en el formato `.Rd`, puede leer más en [Escribir extensiones R](https://cran.r-project.org/doc/manuals/R-exts.html#Rd-format).
Pero generalmente nunca necesitarás mirar archivos `.Rd`, excepto para enviarlos al repositorio Git de tu paquete.

¿Cómo se corresponde este archivo `.Rd` con la documentación que ves en R?
Cuando ejecuta `?add`, `help("add")` o `example("add")`, R busca un archivo `.Rd` que contenga `\alias{add}`.
Luego analiza el archivo, lo convierte a HTML y lo muestra.
@fig-rendered-help-topic-add muestra cómo se vería este tema de ayuda en RStudio:

```{r}
#| label: fig-rendered-help-topic-add
#| echo: false
#| out-width: ~
#| fig-cap: >
#|   Tema de ayuda representado en HTML.
#| fig-alt: >
#|   Captura de pantalla del tema de ayuda para la función add().
knitr::include_graphics("images/man-add.png", dpi = 220)
```

::: callout-warning
## `R CMD check` warning

Debe documentar todas las funciones y conjuntos de datos exportados.
De lo contrario, recibirá esta advertencia de `R CMD check`:

```         
W  checking for missing documentation entries (614ms)
  Undocumented code objects:
    ‘somefunction’
  Undocumented data sets:
    ‘somedata’
  All user-level objects in a package should have documentation entries.
```

Por el contrario, probablemente no desees documentar funciones no exportadas.
Si desea utilizar comentarios de roxygen para la documentación interna, incluya la etiqueta `@noRd` para suprimir la creación del archivo `.Rd`.
:::

Este también es un buen momento para explicar algo que quizás hayas notado en tu archivo `DESCRIPTION`:

```         
Roxygen: list(markdown = TRUE)
```

devtools/usethis incluye esto de forma predeterminada al iniciar un archivo `DESCRIPTION` y le avisa a roxygen2 de que su paquete usa sintaxis de rebajas en sus comentarios de roxygen.[^man-4]

[^man-4]: Esto es parte de la explicación prometida en @sec-description-custom-fields, donde también aclaramos que, con nuestras convenciones actuales, este campo realmente debería llamarse `Config/Needs/roxygen`, en su lugar.
    de `Roxigen`.
    Le recomendamos encarecidamente que utilice Markdown en todos los paquetes nuevos y que migre los paquetes más antiguos pero que se mantienen activamente a la sintaxis Markdown.
    En este caso, puede llamar a `usethis::use_roxygen_md()` para actualizar `DESCRIPTION` y recibir un recordatorio sobre el paquete roxygen2md, que puede ayudar con la conversión.

El proceso de búsqueda de ayuda predeterminado busca dentro de los paquetes **instalados**, por lo que para ver la documentación de su paquete durante el desarrollo, devtools anula las funciones de ayuda habituales con versiones modificadas que saben consultar el paquete **fuente** actual.
Para activar estas anulaciones, necesitarás ejecutar `devtools::load_all()` al menos una vez.
Si siente que sus ediciones en los comentarios de roxygen no están teniendo efecto, verifique que haya regenerado los archivos `.Rd` con `devtools::document()` y que haya cargado su paquete.
Cuando llama a `?Función`, debería ver "Representación de documentación de desarrollo ...".

En resumen, hay cuatro pasos en el flujo de trabajo básico de roxygen2:

1.  Agregue comentarios de roxygen2 a sus archivos `.R`.

2.  Ejecute `devtools::document()` o presione Ctrl/Cmd + Shift + D para convertir los comentarios de roxygen2 en archivos `.Rd`.

3.  Obtenga una vista previa de la documentación con `?función`.

4.  Enjuague y repita hasta que la documentación tenga el aspecto deseado.

### comentarios, bloques y etiquetas de roxygen2 {#sec-man-roxygen-comments}

Ahora que comprende el flujo de trabajo básico, entraremos en más detalles sobre la sintaxis.
Los comentarios de roxygen2 comienzan con `#'` y todos los comentarios de roxygen2 que preceden a una función se denominan colectivamente **bloque**.
Los bloques se dividen en **etiquetas**, que se parecen a `@tagName tagValue`, y el contenido de una etiqueta se extiende desde el final del nombre de la etiqueta hasta el inicio de la siguiente etiqueta [^man-5].
Un bloque puede contener texto antes de la primera etiqueta que se denomina **introducción**. De forma predeterminada, cada bloque genera un único **tema** de documentación, es decir, un único archivo `.Rd`[^man-6] en el directorio `man/`.

[^man-5]: O el final del bloque, si es la última etiqueta.

[^man-6]: el nombre del archivo se deriva automáticamente del objeto que estás documentando.

A lo largo de este capítulo, le mostraremos comentarios de roxygen2 de paquetes tidyverse reales, centrándonos en [stringr](https://stringr.tidyverse.org), ya que las funciones allí tienden a ser bastante sencillas, lo que lleva a documentación comprensible con relativamente poco contexto.
Adjuntamos stringr aquí para que sus funciones tengan un hipervínculo en el libro renderizado (más sobre esto en la sección @sec-man-key-md-features).

```{r}
library(stringr)
```

Aquí hay un primer ejemplo simple: la documentación para `str_unique()`.

```{r}
#' Remove duplicated strings
#'
#' `str_unique()` removes duplicated values, with optional control over
#' how duplication is measured.
#'
#' @param string Input vector. Either a character vector, or something
#'  coercible to one.
#' @param ... Other options used to control matching behavior between duplicate
#'   strings. Passed on to [stringi::stri_opts_collator()].
#' @returns A character vector, usually shorter than `string`.
#' @seealso [unique()], [stringi::stri_unique()] which this function wraps.
#' @examples
#' str_unique(c("a", "b", "c", "b", "a"))
#'
#' # Use ... to pass additional arguments to stri_unique()
#' str_unique(c("motley", "mötley", "pinguino", "pingüino"))
#' str_unique(c("motley", "mötley", "pinguino", "pingüino"), strength = 1)
#' @export
str_unique <- function(string, ...) {
  ...
}
```

Aquí la introducción incluye el título ("Eliminar cadenas duplicadas") y una descripción básica de lo que hace la función.
La introducción va seguida de cinco etiquetas: dos `@param`s, una `@returns`, una `@seealso`, una `@examples` y una `@export`.

Tenga en cuenta que el bloque tiene una longitud de línea intencional (generalmente la misma que se usa para el código R circundante) y la segunda línea y las siguientes de la etiqueta larga `@param` tienen sangría, lo que hace que todo el bloque sea más fácil de escanear.
Puedes obtener más consejos de estilo de roxygen2 en la [guía de estilo de tidyverse](https://style.tidyverse.org/documentation.html).

::: callout-tip
## RStudio

Puede resultar molesto administrar manualmente la longitud de línea de los comentarios de roxygen, así que asegúrese de probar *Code \> Reflow Comment* (Ctrl/Cmd+Shift+/).
:::

Tenga en cuenta también que el orden en que aparecen las etiquetas en sus comentarios de roxygen (o incluso en archivos `.Rd` escritos a mano) no dicta el orden en la documentación representada.
El orden de presentación se determina mediante herramientas dentro de la base R.

Las siguientes secciones profundizan en las etiquetas más importantes.
Comenzamos con la introducción, que proporciona el título, la descripción y los detalles.
Luego cubrimos las entradas (los argumentos de la función), las salidas (el valor de retorno) y los ejemplos.
A continuación, analizamos enlaces y referencias cruzadas y terminamos con técnicas para compartir documentación entre temas.

### Funciones claves de markdown {#sec-man-key-md-features}

En su mayor parte, el conocimiento general de Markdown y R Markdown es suficiente para aprovechar el Markdown en roxygen2.
Pero hay algunas piezas de sintaxis que son tan importantes que queremos resaltarlas aquí.
Los verá en muchos de los ejemplos de este capítulo.

**Comillas invertidas para código en línea**: utilice comillas invertidas para formatear un fragmento de texto como código, es decir, en una fuente de ancho fijo.
Ejemplo:

```{r}
#' I like `thisfunction()`, because it's great.
```

**Corchetes para una función con enlace automático**: incluya texto como `alguna función()` y `algún paquete::alguna función()` entre corchetes para obtener un enlace automático a la documentación de esa función.
Asegúrese de incluir los paréntesis finales, porque tiene un buen estilo y hace que la función se formatee como código, es decir, no es necesario agregar comillas invertidas.
Ejemplo:

```{r}
#' Es obvio que `thisfunction()` es mejor que [otherpkg::otherfunction()]
#' o incluso nuestra propia [función anterior()].
```

**Viñetas**: si hace referencia a una viñeta con una llamada en línea a `vignette("some-topic")`, tiene un doble propósito.
Primero, este es literalmente el código R que ejecutaría para ver una viñeta localmente.
¡Pero espera hay mas!
En muchos contextos renderizados, esto se convierte automáticamente en un hipervínculo a esa misma viñeta en un sitio web pkgdown.
Aquí lo usamos para vincular algunas viñetas muy relevantes[^man-7]:

[^man-7]: Estas llamadas incluyen una especificación explícita de `package = "algúnpaquete"`, ya que no se puede inferir del contexto, es decir, el contexto es un libro en cuarto, no la documentación del paquete.

-   `vignette("rd-formatting", package = "roxygen2")`

-   `vignette("reuse", package = "roxygen2")`

-   `vignette("linking", package = "pkgdown")`

**Listas**: Las listas con viñetas rompen el temido "muro de texto" y pueden hacer que su documentación sea más fácil de escanear.
Puedes usarlos en la descripción de la función o de un argumento y también para el valor de retorno.
No es necesario incluir una línea en blanco antes de la lista, pero eso también está permitido.

```{r}
#' Mejores características de `thisfunction()`:
#' * Huele bien
#' * Tiene buena vibra
```

## Título, descripción, detalles

La introducción proporciona un título, una descripción y, opcionalmente, detalles de la función.
Si bien es posible utilizar etiquetas explícitas en la introducción, normalmente utilizamos etiquetas implícitas cuando es posible:

-   El **título** está tomado de la primera frase.
    Debe escribirse en mayúsculas y minúsculas, no terminar en punto y estar seguido de una línea en blanco.
    El título se muestra en varios índices de funciones (por ejemplo, `help(package = "algúnpaquete")`) y es lo que el usuario normalmente verá cuando explore múltiples funciones.

-   La **descripción** está tomada del siguiente párrafo.
    Se muestra en la parte superior de la documentación y debe describir brevemente las características más importantes de la función.

-   **Detalles** adicionales son cualquier cosa después de la descripción.
    Los detalles son opcionales, pero pueden tener cualquier longitud, por lo que son útiles si desea profundizar en algún aspecto importante de la función.
    Tenga en cuenta que, aunque los detalles aparecen justo después de la descripción en la introducción, aparecen mucho más tarde en la documentación renderizada.

Las siguientes secciones describen cada componente con más detalle y luego analizan algunas etiquetas relacionadas útiles.

### Título

Al escribir el título, es útil pensar en cómo aparecerá en el índice de referencia.
Cuando un usuario hojea el índice, ¿cómo sabrá qué funciones resolverán su problema actual?
Esto requiere pensar en qué tienen en común sus funciones (que no es necesario repetir en cada título) y qué es exclusivo de esa función (que debe resaltarse en el título).

Cuando escribimos este capítulo, encontramos que los títulos de las funciones de stringr eran algo decepcionantes.
Pero proporcionan un útil estudio de caso negativo:

-   `str_detect()`: Detecta la presencia o ausencia de un patrón en una cadena
-   `str_extract()`: Extrae patrones coincidentes de una cadena
-   `str_locate()`: Localiza la posición de los patrones en una cadena
-   `str_match()`: Extrae grupos coincidentes de una cadena

Hay mucha repetición ("pattern", "from a string") y el verbo usado para el nombre de la función se repite en el título, por lo que si aún no comprende la función, es poco probable que el título le ayude mucho.
¡Esperamos haber mejorado esos títulos cuando leas esto!

En cambio, estos títulos de dplyr son mucho mejores[^man-8]:

[^man-8]: Como todos los ejemplos, es posible que estos hayan cambiado un poco desde que escribimos este libro, porque nos esforzamos constantemente por hacerlo mejor.
    Podrías comparar lo que hay en el libro con lo que usamos ahora y considerar si crees que es una mejora.

-   `mutate()`: Crear, modificar y eliminar columnas
-   `summarise()`: Resume cada grupo en una fila
-   `filtro()`: Mantiene las filas que coinciden con una condición
-   `select()`: Mantener o eliminar columnas usando sus nombres y tipos
-   `arrange()`: Ordena filas usando valores de columna

Aquí intentamos describir de manera sucinta lo que hace la función, asegurándonos de describir si afecta a filas, columnas o grupos.
Hacemos nuestro mejor esfuerzo para usar sinónimos, en lugar de repetir el nombre de la función, para darle a la gente otra oportunidad de comprender la intención de la función.

### Descripción

El propósito de la descripción es resumir el objetivo de la función, generalmente en un solo párrafo.
Esto puede ser un desafío para funciones simples, porque puede parecer que simplemente estás repitiendo el título de la función.
Si puedes, intenta encontrar una redacción ligeramente diferente.
Está bien si esto te parece un poco repetitivo; A menudo resulta útil para los usuarios ver lo mismo expresado de dos maneras diferentes.
Es un poco de trabajo extra, pero el esfuerzo extra a menudo vale la pena.
Aquí está la descripción de `str_detect()`:

```{r}
#' Detect the presence/absence of a match
#'
#' `str_detect()` returns a logical vector with `TRUE` for each element of
#' `string` that matches `pattern` and `FALSE` otherwise. It's equivalent to
#' `grepl(pattern, string)`.
```

Si desea más de un párrafo, debe usar una etiqueta `@description` explícita para evitar que el segundo párrafo (y los siguientes) se conviertan en `@details`.
Aquí hay una `@description` de dos párrafos de `str_view()`:

```{r}
#' View strings and matches
#'
#' @description
#' `str_view()` is used to print the underlying representation of a string and
#' to see how a `pattern` matches.
#'
#' Matches are surrounded by `<>` and unusual whitespace (i.e. all whitespace
#' apart from `" "` and `"\n"`) are surrounded by `{}` and escaped. Where
#' possible, matches and unusual whitespace are coloured blue and `NA`s red.
```

Aquí hay otro ejemplo de `str_like()`, que tiene una lista con viñetas en `@description`:

```{r}
#' Detect a pattern in the same way as `SQL`'s `LIKE` operator
#'
#' @description
#' `str_like()` follows the conventions of the SQL `LIKE` operator:
#'
#' * Must match the entire string.
#' * `_` matches a single character (like `.`).
#' * `%` matches any number of characters (like `.*`).
#' * `\%` and `\_` match literal `%` and `_`.
#' * The match is case insensitive by default.
```

Básicamente, si vas a incluir una línea vacía en tu descripción, necesitarás usar una etiqueta `@description` explícita.

Finalmente, a menudo es particularmente difícil escribir una buena descripción si acabas de escribir la función, porque el propósito a menudo parece muy obvio.
Haz tu mejor esfuerzo y vuelve más tarde, cuando hayas olvidado exactamente qué hace la función.
Una vez que haya vuelto a derivar lo que hace la función, podrá escribir una mejor descripción.

### Detalles

Los `@details` son solo cualquier detalle o explicación adicional que crea que su función necesita.
La mayoría de las funciones no necesitan detalles, pero algunas funciones necesitan muchos.
Si tiene mucha información que transmitir, es una buena idea utilizar títulos de rebajas informativos para dividir los detalles en secciones manejables[^man-9].
Aquí hay un ejemplo de `dplyr::mutate()`. Hemos omitido algunos de los detalles para que este ejemplo sea breve, pero aún así deberías tener una idea de cómo usamos los títulos para dividir el contenido en partes que se pueden leer:

[^man-9]: En el código anterior, es posible que veas el uso de `@section title:` que se usaba para crear secciones antes de que roxygen2 tuviera soporte completo para rebajas.
    Si los ha usado en el pasado, ahora puede convertirlos en títulos de markdown.

```{r}
#' Create, modify, and delete columns
#'
#' `mutate()` creates new columns that are functions of existing variables.
#' It can also modify (if the name is the same as an existing
#' column) and delete columns (by setting their value to `NULL`).
#'
#' @section Useful mutate functions:
#'
#' * [`+`], [`-`], [log()], etc., for their usual mathematical meanings
#' 
#' ...
#'
#' @section Grouped tibbles:
#'
#' Because mutating expressions are computed within groups, they may
#' yield different results on grouped tibbles. This will be the case
#' as soon as an aggregating, lagging, or ranking function is
#' involved. Compare this ungrouped mutate:
#' 
#' ...
```

Este es un buen momento para recordarnos que, aunque un título como "Funciones de mutación útiles" en el ejemplo anterior aparece inmediatamente después de la descripción en el bloque roxygen, el contenido aparece mucho más tarde en la documentación renderizada.
Los detalles (ya sea que usen encabezados de sección o no) aparecen después del uso de la función, los argumentos y el valor de retorno.

## Argumentos

Para la mayoría de las funciones, la mayor parte de su trabajo se destinará a documentar cómo cada argumento afecta el resultado de la función.
Para este propósito, usará `@param` (abreviatura de parámetro, sinónimo de argumento) seguido del nombre del argumento y una descripción de su acción.

La máxima prioridad es proporcionar un resumen sucinto de las entradas permitidas y lo que hace el parámetro.
Por ejemplo, así es como `str_detect()` documenta el `string`:

```{r}
#' @param string Input vector. Either a character vector, or something
#'  coercible to one.
```

Y aquí están tres de los argumentos de `str_flatten()`:

```{r}
#' @param collapse String to insert between each piece. Defaults to `""`.
#' @param last Optional string to use in place of the final separator.
#' @param na.rm Remove missing values? If `FALSE` (the default), the result 
#'   will be `NA` if any element of `string` is `NA`.
```

Tenga en cuenta que `@param collapse` y `@param na.rm` describen sus argumentos predeterminados.
Esta suele ser una buena práctica porque el uso de la función (que muestra los valores predeterminados) y la descripción del argumento suelen estar bastante separados en la documentación representada.
Pero hay desventajas.
La principal es que esta duplicación significa que necesitarás realizar actualizaciones en dos lugares si cambias el valor predeterminado; Creemos que esta pequeña cantidad de trabajo extra vale la pena para facilitar la vida del usuario.

Si un argumento tiene un conjunto fijo de posibles parámetros, debes enumerarlos.
Si son simples, puedes enumerarlos en una oración, como en `str_trim()`:

```{r}
#' @param side Side on which to remove whitespace: `"left"`, `"right"`, or
#'   `"both"` (the default).
```

Si necesitan más explicaciones, puedes usar una lista con viñetas, como en `str_wrap()`:

```{r}
#' @param whitespace_only A boolean.
#'   * `TRUE` (the default): wrapping will only occur at whitespace.
#'   * `FALSE`: can break on any non-word character (e.g. `/`, `-`).
```

La documentación para la mayoría de los argumentos será relativamente breve, a menudo una o dos oraciones.
Pero debes ocupar todo el espacio que necesites y en breve verás algunos ejemplos de documentos con argumentos de varios párrafos.

### Multiple arguments

If the behavior of multiple arguments is tightly coupled, you can document them together by separating the names with commas (with no spaces).
For example, `x` and `y` are interchangeable in `str_equal()`, so they're documented together:

```{r}
#' @param x,y A pair of character vectors.
```

In `str_sub()`, `start` and `end` define the range of characters to replace.
But instead of supplying both, you can use just `start` if you pass in a two-column matrix.
So it makes sense to document them together:

```{r}
#' @param start,end A pair of integer vectors defining the range of characters
#'   to extract (inclusive).
#'
#'   Alternatively, instead of a pair of vectors, you can pass a matrix to
#'   `start`. The matrix should have two columns, either labelled `start`
#'   and `end`, or `start` and `length`.
```

In `str_wrap()`, `indent` and `exdent` define the indentation for the first line and all subsequent lines, respectively:

```{r}
#' @param indent,exdent A non-negative integer giving the indent for the
#'   first line (`indent`) and all subsequent lines (`exdent`).
```

### Inheriting arguments

If your package contains many closely related functions, it's common for them to have arguments that share the same name and meaning.
It would be both annoying and error prone to copy and paste the same `@param` documentation to every function, so roxygen2 provides `@inheritParams` which allows you to inherit argument documentation from another function, possibly even in another package.

stringr uses `@inheritParams` extensively because most functions have `string` and `pattern` arguments.
The detailed and definitive documentation belongs to `str_detect()`:

```{r}
#' @param string Input vector. Either a character vector, or something
#'  coercible to one.
#' @param pattern Pattern to look for.
#'
#'   The default interpretation is a regular expression, as described in
#'   `vignette("regular-expressions")`. Use [regex()] for finer control of the
#'   matching behaviour.
#'
#'   Match a fixed string (i.e. by comparing only bytes), using
#'   [fixed()]. This is fast, but approximate. Generally,
#'   for matching human text, you'll want [coll()] which
#'   respects character matching rules for the specified locale.
#'
#'   Match character, word, line and sentence boundaries with
#'   [boundary()]. An empty pattern, "", is equivalent to
#'   `boundary("character")`.
```

Then the other stringr functions use `@inheritParams str_detect` to get this detailed documentation for `string` and `pattern` without having to duplicate that text.

`@inheritParams` only inherits docs for arguments that the function actually uses and that aren't already documented, so you can document some arguments locally and inherit others.
`str_match()` uses this to inherit `str_detect()`'s standard documentation for the `string` argument, while providing its own specialized documentation for `pattern`:

```{r}
#' @inheritParams str_detect
#' @param pattern Unlike other stringr functions, `str_match()` only supports
#'   regular expressions, as described `vignette("regular-expressions")`. 
#'   The pattern should contain at least one capturing group.
```

Now that we've discussed default values and inheritance we can bring up one more dilemma.
Sometimes there's tension between giving detailed information on an argument (acceptable values, default value, how the argument is used, etc.) and making the documentation amenable to reuse in other functions (which might differ in some specifics).
This can motivate you to assess whether it's truly worth it for related functions to handle the same input in different ways or if standardization would be beneficial.

You can inherit documentation from a function in another package by using the standard `::` notation, i.e. `@inheritParams anotherpackage::function`.
This does introduce one small annoyance: now the documentation for your package is no longer self-contained and the version of `anotherpackage` can affect the generated docs.
Beware of spurious diffs introduced by contributors who run `devtools::document()` with a different installed version of the inherited-from package.

## Return value {#sec-man-returns}

A function's output is as important as its inputs.
Documenting the output is the job of the `@returns`[^man-10] tag.
Here the priority is to describe the overall "shape" of the output, i.e. what sort of object it is, and its dimensions (if that makes sense).
For example, if your function returns a vector you might describe its type and length, or if your function returns a data frame you might describe the names and types of the columns and the expected number of rows.

[^man-10]: For historical reasons, you can also use `@return`, but we now favor `@returns` because it reads more naturally.

The `@returns` documentation for functions in stringr is straightforward because almost all functions return some type of vector with the same length as one of the inputs.
For example, here's how `str_like()` describes its output:

```{r}
#' @returns A logical vector the same length as `string`.
```

A more complicated case is the joint documentation for `str_locate()` and `str_locate_all()`[^man-11].
`str_locate()` returns an integer matrix, and `str_locate_all()` returns a list of matrices, so the text needs to describe what determines the rows and columns.

[^man-11]: We'll come back how to document multiple functions in one topic in @sec-man-multiple-functions.

```{r}
#' @returns
#' * `str_locate()` returns an integer matrix with two columns and
#'   one row for each element of `string`. The first column, `start`,
#'   gives the position at the start of the match, and the second column, `end`,
#'   gives the position of the end.
#'
#'* `str_locate_all()` returns a list of integer matrices with the same
#'   length as `string`/`pattern`. The matrices have columns `start` and `end`
#'   as above, and one row for each match.
#' @seealso
#'   [str_extract()] for a convenient way of extracting matches,
#'   [stringi::stri_locate()] for the underlying implementation.
```

In other cases it can be easier to figure out what to highlight by thinking about the set of functions and how they differ.
For example, most dplyr functions return a data frame, so just saying `@returns A data frame` is not very useful.
Instead, we tried to identify exactly what makes each function different.
We decided it makes sense to describe each function in terms of how it affects the rows, the columns, the groups, and the attributes.
For example, this describes the return value of `dplyr::filter()`:

```{r}
#' @returns
#' An object of the same type as `.data`. The output has the following properties:
#'
#' * Rows are a subset of the input, but appear in the same order.
#' * Columns are not modified.
#' * The number of groups may be reduced (if `.preserve` is not `TRUE`).
#' * Data frame attributes are preserved.
```

`@returns` is also a good place to describe any important warnings or errors that the user might see.
For example `readr::read_csv()` mentions what happens if there are any parsing problems:

```{r}
#' @returns A [tibble()]. If there are parsing problems, a warning will alert you.
#'   You can retrieve the full details by calling [problems()] on your dataset.
```

::: callout-warning
## Submitting to CRAN

For your initial CRAN submission, all functions must document their return value.
While this may not be scrutinized in subsequent submissions, it's still a good practice.
There's currently no way to check that you've documented the return value of every function (we're [working on it](https://github.com/r-lib/roxygen2/issues/1334)) which is why you'll notice some tidyverse functions lack output documentation.
But we certainly aspire to provide this information across the board.
:::

## Examples {#sec-man-examples}

Describing what a function does is great, but *showing* how it works is even better.
That's the role of the `@examples` tag, which uses executable R code to demonstrate what a function can do.
Unlike other parts of the documentation where we've focused mainly on what you should write, here we'll briefly give some content advice and then focus mainly on the mechanics.

The main dilemma with examples is that you must jointly satisfy two requirements:

-   Your example code should be readable and realistic.
    Examples are documentation that you provide for the benefit of the user, i.e. a real human, working interactively, trying to get their actual work done with your package.

-   Your example code must run without error and with no side effects in many non-interactive contexts over which you have limited or no control, such as when CRAN runs `R CMD check` or when your package website is built via GitHub Actions.

It turns out that there is often tension between these goals and you'll need to find a way to make your examples as useful as you can for users, while also satisfying the requirements of CRAN (if that's your goal) or other automated infrastructure.

The mechanics of examples are complex because they must never error and they're executed in four different situations:

-   Interactively using the `example()` function.
-   During `R CMD check` on your computer, or another computer you control (e.g. in GitHub Actions).
-   During `R CMD check` run by CRAN.
-   When your pkgdown website is being built, often via GitHub Actions or similar.

After discussing what to put in your examples, we'll talk about keeping your examples self-contained, how to display errors if needed, handling dependencies, running examples conditionally, and alternatives to the `@examples` tag for including example code.

::: callout-tip
## RStudio

When preparing `.R` scripts or `.Rmd` / `.qmd` reports, it's handy to use Ctrl/Cmd + Enter or the *Run* button to send a line of R code to the console for execution.
Happily, you can use the same workflow for executing and developing the `@examples` in your roxygen comments.
Remember to do `devtools::load_all()` often, to stay synced with the package source.
:::

### Contents

Use examples to first show the basic operation of the function, then to highlight any particularly important properties.
For example, `str_detect()` starts by showing a few simple variations and then highlights a feature that's easy to miss: as well as passing a vector of strings and one pattern, you can also pass one string and vector of patterns.

```{r}
#' @examples
#' fruit <- c("apple", "banana", "pear", "pineapple")
#' str_detect(fruit, "a")
#' str_detect(fruit, "^a")
#' str_detect(fruit, "a$")
#' 
#' # Also vectorised over pattern
#' str_detect("aecfg", letters)
```

Try to stay focused on the most important features without getting into the weeds of every last edge case: if you make the examples too long, it becomes hard for the user to find the key application that they're looking for.
If you find yourself writing very long examples, it may be a sign that you should write a vignette instead.

There aren't any formal ways to break up your examples into sections but you can use sectioning comments that use many `---` to create a visual breakdown.
Here's an example from `tidyr::chop()`:

```{r}
#' @examples
#' # Chop ----------------------------------------------------------------------
#' df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
#' # Note that we get one row of output for each unique combination of
#' # non-chopped variables
#' df %>% chop(c(y, z))
#' # cf nest
#' df %>% nest(data = c(y, z))
#'
#' # Unchop --------------------------------------------------------------------
#' df <- tibble(x = 1:4, y = list(integer(), 1L, 1:2, 1:3))
#' df %>% unchop(y)
#' df %>% unchop(y, keep_empty = TRUE)
```

Strive to keep the examples focused on the specific function that you're documenting.
If you can make the point with a familiar built-in dataset, like `mtcars`, do so.
If you find yourself needing to do a bunch of setup to create a dataset or object to use in the example, it may be a sign that you need to create a package dataset or even a helper function.
See @sec-data, @sec-data-example-path-helper, and @sec-testing-advanced-fixture-helper for ideas.
Making it easy to write (and read) examples will greatly improve the quality of your documentation.

Also, remember that examples are not tests.
Examples should be focused on the authentic and typical usage you've designed for and that you want to encourage.
The test suite is the more appropriate place to exhaustively exercise all of the arguments and to explore weird, pathological edge cases.

### Leave the world as you found it

Your examples should be self-contained.
For example, this means:

-   If you modify `options()`, reset them at the end of the example.
-   If you create a file, create it somewhere in `tempdir()`, and make sure to delete it at the end of the example.
-   Don't change the working directory.
-   Don't write to the clipboard (unless a user is present to provide some form of consent).

This has a lot of overlap with our recommendations for tests (see section @sec-testing-design-self-contained) and even for the R functions in your package (see section @sec-code-r-landscape).
However, due to the way that examples are run during `R CMD check`, the tools available for making examples self-contained are much more limited.
Unfortunately, you can't use the withr package or even `on.exit()` to schedule clean up, like restoring options or deleting a file.
Instead, you'll need to do it by hand.
If you can avoid doing something that must then be undone, that is the best way to go and this is especially true for examples.

These constraints are often in tension with good documentation, if you're trying to document a function that somehow changes the state of the world.
For example, you have to "show your work", i.e. all of your code, which means that your users will see all of the setup and teardown, even it is not typical for authentic usage.
If you're finding it hard to follow the rules, this might be another sign to switch to a vignette (see @sec-vignettes).

::: callout-warning
## Submitting to CRAN

Many of these constraints are also mentioned in the [CRAN repository policy](https://cran.r-project.org/web/packages/policies.html), which you must adhere to when submitting to CRAN.
Use find in page to locate "malicious or anti-social" to see the details.
:::

Additionally, you want your examples to send the user on a short walk, not a long hike.
Examples need to execute relatively quickly so users can quickly see the results, it doesn't take ages to build your website, automated checks happen quickly, and it doesn't take up computing resources when submitting to CRAN.

::: callout-warning
## Submitting to CRAN

All examples must run in under 10 minutes.
:::

### Errors {#sec-man-examples-errors}

Your examples cannot throw any errors, so don't include flaky code that can fail for reasons beyond your control.
In particular, it's best to avoid accessing websites, because `R CMD check` will fail whenever the website is down.

What can you do if you want to include code that causes an error for the purposes of teaching?
There are two basic options:

-   You can wrap the code in `try()` so that the error is shown, but doesn't stop execution of the examples.
    For example, `dplyr::bind_cols()` uses `try()` to show you what happens if you attempt to column-bind two data frames with different numbers of rows:

    ```{r}
    #' @examples
    #' ...
    #' # Row sizes must be compatible when column-binding
    #' try(bind_cols(tibble(x = 1:3), tibble(y = 1:2)))
    ```

-   You can wrap the code in `\dontrun{}`[^man-12], so it is never run by `example()`. The example above would look like this if you used `\dontrun{}` instead of `try()`.

    ```{r}
    #' # Row sizes must be compatible when column-binding
    #' \dontrun{
    #' bind_cols(tibble(x = 1:3), tibble(y = 1:2)))
    #' }
    ```

[^man-12]: You used to be able to use `\donttest{}` for a similar purpose, but we no longer recommend it because CRAN sets a special flag that causes the code to be executed anyway.

We generally recommend using `try()` so that the reader can see an example of the error in action.

::: callout-warning
## Submitting to CRAN

For the initial CRAN submission of your package, all functions must have at least one example and the example code can't all be wrapped inside `\dontrun{}`.
If the code can only be run under specific conditions, use the techniques below to express those pre-conditions.
:::

### Dependencies and conditional execution {#sec-man-examples-dependencies-conditional-execution}

An additional source of errors in examples is the use of external dependencies: you can only use packages in your examples that your package formally depends on (i.e. that appear in `Imports` or `Suggests`).
Furthermore, example code is run in the user's environment, not the package environment, so you'll have to either explicitly attach the dependency with `library()` or refer to each function with `::`.
For example, dbplyr is a dplyr extension package, so all of its examples start with `library(dplyr)`:

```{r}
#' @examples
#' library(dplyr)
#' df <- data.frame(x = 1, y = 2)
#'
#' df_sqlite <- tbl_lazy(df, con = simulate_sqlite())
#' df_sqlite %>% summarise(x = sd(x, na.rm = TRUE)) %>% show_query()
```

In the past, we recommended only using code from suggested packages inside a block like this:

```{r}
#' @examples
#' if (requireNamespace("suggestedpackage", quietly = TRUE)) { 
#'   # some example code
#' }
```

We no longer believe that approach is a good idea, because:

-   Our policy is to expect that suggested packages are installed when running `R CMD check`[^man-13] and this informs what we do in examples, tests, and vignettes.
-   The cost of putting example code inside `{ … }` is high: you can no longer see intermediate results, such as when the examples are rendered in the package's website. The cost of a package not being installed is low: users can usually recognize the associated error and resolve it themselves, i.e. by installing the missing package.

[^man-13]: This is certainly true for CRAN and is true in most other automated checking scenarios, such as our GitHub Actions workflows.

In other cases, your example code may depend on something other than a package.
For example, if your examples talk to a web API, you probably only want to run them for an authenticated user, and never want such code to run on CRAN.
In this case, you really do need conditional execution.
The entry-level solution is to express this explicitly:

```{r}
#' @examples
#' if (some_condition()) {
#'   # some example code
#' }
```

The condition could be quite general, such as `interactive()`, or very specific, such as a custom predicate function provided by your package.
But this use of `if()` still suffers from the downside highlighted above, where the rendered examples don't clearly show what's going on inside the `{ … }` block.

The `@examplesIf` tag is a great alternative to `@examples` in this case:

```{r}
#' @examplesIf some_condition()
#' some_other_function()
#' some_more_functions()
```

This looks almost like the snippet just above, but has several advantages:

-   Users won't actually see the `if() { … }` machinery when they are reading your documentation from within R or on a pkgdown website.
    Users only see realistic code.

-   The example code renders fully in pkgdown.

-   The example code runs when it should and does not run when it should not.

-   This doesn't run afoul of CRAN's prohibition of putting all your example code inside `\dontrun{}`.

For example, [googledrive](https://googledrive.tidyverse.org/reference/index.html) uses `@examplesIf` in almost every function, guarded by `googledrive::drive_has_token()`.
Here's how the examples for `googledrive::drive_publish()` begin:

```{r}
#' @examplesIf drive_has_token()
#' # Create a file to publish
#' file <- drive_example_remote("chicken_sheet") %>%
#'   drive_cp()
#'
#' # Publish file
#' file <- drive_publish(file)
#' ...
```

The example code doesn't run on CRAN, because there's no token.
It does run when the pkgdown site is built, because we can set up a token securely.
And, if a normal user executes this code, they'll be prompted to sign in to Google, if they haven't already.

### Intermixing examples and text

An alternative to examples is to use R Markdown code blocks elsewhere in your roxygen comments, either ```` ```R ```` if you just want to show some code, or ```` ```{r} ```` if you want the code to be run.
These can be effective techniques but there are downsides to each:

-   The code in ```` ```R ```` blocks is never run; this means it's easy to accidentally introduce syntax errors or to forget to update it when your package changes.
-   The code in ```` ```{r} ```` blocks is run every time you document the package. This has the nice advantage of including the output in the documentation (unlike examples), but the code can't take very long to run or your iterative documentation workflow will become quite painful.

## Re-using documentation

roxygen2 provides a number of features that allow you to reuse documentation across topics.
They are documented in `vignette("reuse", package = "roxygen2")`, so here we'll focus on the three most important:

-   Documenting multiple functions in one topic.
-   Inheriting documentation from another topic.
-   Using child documents to share prose between topics, or to share between documentation topics and vignettes.

### Multiple functions in one topic {#sec-man-multiple-functions}

By default, each function gets its own documentation topic, but if two functions are very closely connected, you can combine the documentation for multiple functions into a single topic.
For example, take `str_length()` and `str_width()`, which provide two different ways of computing the size of a string.
As you can see from the description, both functions are documented together, because this makes it easier to see how they differ:

```{r}
#' The length/width of a string
#'
#' @description
#' `str_length()` returns the number of codepoints in a string. These are
#' the individual elements (which are often, but not always letters) that
#' can be extracted with [str_sub()].
#'
#' `str_width()` returns how much space the string will occupy when printed
#' in a fixed width font (i.e. when printed in the console).
#'
#' ...
str_length <- function(string) {
  ...
}
```

To merge the two topics, `str_width()` uses `@rdname str_length` to add its documentation to an existing topic:

```{r}
#' @rdname str_length
str_width <- function(string) {
  ...
}
```

This technique works best for functions that have a lot in common, i.e. similar return values and examples, in addition to similar arguments.

### Inheriting documentation

In other cases, functions in a package might share many related behaviors, but aren't closely enough connected that you want to document them together.
We've discussed `@inheritParams` above, but there are three variations that allow you to inherit other things:

-   `@inherit source_function` will inherit all supported components from `source_function()`.

-   `@inheritSection source_function Section title` will inherit the single section with title "Section title" from `source_function()`.

-   `@inheritDotParams` automatically generates parameter documentation for `...` for the common case where you pass `...` on to another function.

See <https://roxygen2.r-lib.org/articles/reuse.html#inheriting-documentation> for more details.

### Child documents

Finally, you can reuse the same `.Rmd` or `.md` document in the function documentation, `README.Rmd`, and vignettes by using R Markdown child documents.
The syntax looks like this:

```{r}
#' ```{r child = "man/rmd/filename.Rmd"}
#' ```
```

This is a feature we use very sparingly in the tidyverse, but one place we do use it is in dplyr, because a number of functions use the same syntax as `select()` and we want to provide all the info in one place:

```{r}
#' # Overview of selection features
#'
#' ```{r, child = "man/rmd/overview.Rmd"}
#' ```
```

Then `man/rmd/overview.Rmd` contains the repeated markdown:

``` md
Tidyverse selections implement a dialect of R where operators make
it easy to select variables:

- `:` for selecting a range of consecutive variables.
- `!` for taking the complement of a set of variables.
- `&` and `|` for selecting the intersection or the union of two
  sets of variables.
- `c()` for combining selections.

...
```

If the Rmd file contains roxygen (Markdown-style) links to other help topics, then some care is needed.
See <https://roxygen2.r-lib.org/dev/articles/reuse.html#child-documents> for details.

## Help topic for the package {#sec-man-package-doc}

This chapter focuses on function documentation, but remember you can document other things, as detailed in `vignette("rd-other", package = "roxygen2")`.
In particular, you can create a help topic for the package itself by documenting the special sentinel `"_PACKAGE"`.
The resulting `.Rd` file automatically pulls in information parsed from the `DESCRIPTION`, including title, description, list of authors, and useful URLs.
This help topic appears alongside all your other topics and can also be accessed with `package?pkgname`, e.g. `package?usethis`, or even just `?usethis`.

We recommend calling `usethis::use_package_doc()` to set up this package-level documentation in a dummy file `R/{pkgname}-package.R`, whose contents will look something like this:

```{r, eval = FALSE}
#' @keywords internal 
"_PACKAGE"
```

The `R/{pkgname}-package.R` file is the main reason we wanted to mention `use_package_doc()` and package-level documentation here.
It turns out there are a few other package-wide housekeeping tasks for which this file is a very natural home.
For example, it's a sensible, central location for import directives, i.e. for importing individual functions from your dependencies or even entire namespaces.
In @sec-dependencies-in-imports-r-code, we recommend importing specific functions via `usethis::use_import_from()` and this function is designed to write the associated roxygen tags into the `R/{pkgname}-package.R` file created by `use_package_doc()`.
So, putting it all together, this is a minimal example of how the `R/{pkgname}-package.R` file might look:

```{r, eval = FALSE}
#' @keywords internal 
"_PACKAGE"

# The following block is used by usethis to automatically manage
# roxygen namespace tags. Modify with care!
## usethis namespace: start
#' @importFrom glue glue_collapse
## usethis namespace: end
NULL
```

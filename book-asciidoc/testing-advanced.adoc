[[sec-testing-advanced]]
= T√©cnicas de prueba avanzadas
:description: Aprenda a crear un paquete, la unidad fundamental de contenido compartible, reutilizable, y c√≥digo R reproducible.
:lang: es

[IMPORTANT]
====
Sus archivos de prueba no deben incluir estas llamadas `library()`. Tambi√©n solicitamos expl√≠citamente testthat edici√≥n 3, pero en un paquete real esto se declarar√° en DESCRIPTION.

[source,r,cell-code]
----
library(testthat)
local_edition(3)
----

====

== Accesorios de prueba

Cuando no sea pr√°ctico hacer que su prueba sea completamente autosuficiente, prefiera hacer que el objeto, la l√≥gica o las condiciones necesarios est√©n disponibles de una manera estructurada y expl√≠cita. Hay un t√©rmino preexistente para esto en ingenier√≠a de software: un _dispositivo de prueba_.

____
Un dispositivo de prueba es algo que se utiliza para probar consistentemente alg√∫n elemento, dispositivo o software. ‚Äî Wikipedia
____

La idea principal es que debemos hacer que sea lo m√°s f√°cil y obvio posible organizar el mundo en un estado propicio para las pruebas. Describimos varias soluciones espec√≠ficas a este problema:

* Poner c√≥digo repetido en una funci√≥n auxiliar de tipo constructor. T√©ngalo en cuenta si se demuestra que la construcci√≥n es lenta.
* Si el c√≥digo repetido tiene efectos secundarios, escriba una funci√≥n `local++_*++()` personalizada para hacer lo que sea necesario y limpiar despu√©s.
* Si los m√©todos anteriores son demasiado lentos o inc√≥modos y lo que necesita es bastante estable, gu√°rdelo como un archivo est√°tico y c√°rguelo.

[[sec-testing-advanced-fixture-helper]]
=== Crear `cosas++_++√∫tiles` con una funci√≥n auxiliar

¬øEs complicado crear una `useful++_++thing`? ¬øSe necesitan varias l√≠neas de c√≥digo, pero no mucho tiempo ni memoria? En ese caso, escriba una funci√≥n auxiliar para crear una `useful++_++thing` a pedido:

[source,r,cell-code]
----
new_useful_thing <- function() {
  # tu complicado c√≥digo para crear algo √∫til va aqu√≠
}
----

y llamar a ese ayudante en las pruebas afectadas:

[source,r,cell-code]
----
test_that("foofy() does this", {
  useful_thing1 <- new_useful_thing()
  expect_equal(foofy(useful_thing1, x = "this"), EXPECTED_FOOFY_OUTPUT)
})

test_that("foofy() does that", {
  useful_thing2 <- new_useful_thing()
  expect_equal(foofy(useful_thing2, x = "that"), EXPECTED_FOOFY_OUTPUT)
})
----

¬øD√≥nde deber√≠a definirse el asistente `new++_++useful++_++thing()`? Esto vuelve a lo que describimos en <<sec-tests-files-overview>>. Los ayudantes de prueba se pueden definir debajo de `R/`, como cualquier otra utilidad interna de su paquete. Otra ubicaci√≥n popular es en un archivo auxiliar de prueba, por ejemplo, `tests/testthat/helper.R`. Una caracter√≠stica clave de ambas opciones es que los asistentes est√°n disponibles durante el mantenimiento interactivo a trav√©s de `devtools::load++_++all()`.

Si es complicado Y costoso crear una `useful++_++thing`, su funci√≥n auxiliar podr√≠a incluso usar la memorizaci√≥n para evitar un nuevo c√°lculo innecesario. Una vez que tienes una ayuda como `new++_++useful++_++thing()`, a menudo descubres que tiene usos m√°s all√° de las pruebas, por ejemplo, detr√°s de escena en una vi√±eta. A veces incluso te das cuenta de que debes definirlo debajo de `R/` y exportarlo y documentarlo, para que puedas usarlo libremente en documentaci√≥n y pruebas.

=== Crear (y destruir) una `cosa++_++√∫til` "`local`"

SHasta ahora, nuestro ejemplo de `useful++_++thing` era un objeto R normal, que se limpia autom√°ticamente al final de cada prueba. ¬øQu√© pasa si la creaci√≥n de algo √∫til tiene un efecto secundario en el sistema de archivos local, en un recurso remoto, en las opciones de sesi√≥n de R, en las variables de entorno o similares? Entonces su funci√≥n auxiliar deber√≠a crear una `useful++_++thing` *y limpiarla despu√©s*. En lugar de un simple constructor `new++_++useful++_++thing()`, escribir√°s una funci√≥n personalizada al estilo de las funciones `local++_*++()` de withr:

[source,r,cell-code]
----
local_useful_thing <- function(..., env = parent.frame()) {
  # tu complicado c√≥digo para crear algo √∫til va aqu√≠
  withr::defer(
    # tu complicado c√≥digo para limpiar despu√©s de algo √∫til va aqu√≠
    envir = env
  )
}
----

√öselo en sus pruebas de esta manera:

[source,r,cell-code]
----
test_that("foofy() does this", {
  useful_thing1 <- local_useful_thing()
  expect_equal(foofy(useful_thing1, x = "this"), EXPECTED_FOOFY_OUTPUT)
})

test_that("foofy() does that", {
  useful_thing2 <- local_useful_thing()
  expect_equal(foofy(useful_thing2, x = "that"), EXPECTED_FOOFY_OUTPUT)
})
----

¬øD√≥nde deber√≠a definirse el asistente `local++_++useful++_++thing()`? Se aplican todos los consejos dados anteriormente para `new++_++useful++_++thing()`: def√≠nalo debajo de `R/` o en un archivo auxiliar de prueba.

Para obtener m√°s informaci√≥n sobre c√≥mo escribir ayudas personalizadas como `local++_++useful++_++thing()`, consulte la https://testthat.r-lib.org/articles/test-fixtures.html[vi√±eta de testthat en dispositivos de prueba].

[[sec-testing-advanced-concrete-fixture]]
=== Almacenar una `cosa++_++√∫til` concreta de forma persistente

Si crear una `useful++_++thing` es costosa, en t√©rminos de tiempo o memoria, tal vez no necesites volver a crearla para cada ejecuci√≥n de prueba. Puede crear `useful++_++thing` una vez, almacenarlo como un dispositivo de prueba est√°tico y cargarlo en las pruebas que lo necesiten. Aqu√≠ hay un boceto de c√≥mo podr√≠a verse esto:

[source,r,cell-code]
----
test_that("foofy() does this", {
  useful_thing1 <- readRDS(test_path("fixtures", "useful_thing1.rds"))
  expect_equal(foofy(useful_thing1, x = "this"), EXPECTED_FOOFY_OUTPUT)
})

test_that("foofy() does that", {
  useful_thing2 <- readRDS(test_path("fixtures", "useful_thing2.rds"))
  expect_equal(foofy(useful_thing2, x = "that"), EXPECTED_FOOFY_OUTPUT)
})
----

Ahora podemos revisar una lista de archivos anterior, que abordaba exactamente este escenario:

....
.
‚îú‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ testthat
    ‚îÇ   ‚îú‚îÄ‚îÄ fixtures
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ make-useful-things.R
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useful_thing1.rds
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useful_thing2.rds
    ‚îÇ   ‚îú‚îÄ‚îÄ helper.R
    ‚îÇ   ‚îú‚îÄ‚îÄ setup.R
    ‚îÇ   ‚îî‚îÄ‚îÄ (all the test files)
    ‚îî‚îÄ‚îÄ testthat.R
....

Esto muestra archivos de prueba est√°ticos almacenados en `tests/testthat/fixtures/`, pero tambi√©n observe el script R complementario, `make-useful-things.R`. A partir del an√°lisis de datos, todos sabemos que no existe un script que se ejecute solo una vez. El refinamiento y la iteraci√≥n son inevitables. Esto tambi√©n es v√°lido para objetos de prueba como `useful++_++thing1.rds`. Recomendamos encarecidamente guardar el c√≥digo R utilizado para crear los objetos de prueba, para que puedan volver a crearse seg√∫n sea necesario.

== Construyendo sus propias herramientas de prueba

Volvamos al tema de la duplicaci√≥n en su c√≥digo de prueba. Le recomendamos que tenga una mayor tolerancia a la repetici√≥n en el c√≥digo de prueba, con el fin de hacer que sus pruebas sean obvias. Pero todav√≠a hay un l√≠mite en cuanto a la cantidad de repetici√≥n que se puede tolerar. Hemos cubierto t√©cnicas como cargar objetos est√°ticos con `test++_++path()`, escribir un constructor como `new++_++useful++_++thing()` o implementar un dispositivo de prueba como `local++_++useful++_++thing()`. Hay incluso m√°s tipos de ayudas de prueba que pueden resultar √∫tiles en determinadas situaciones.

=== Ayudante definido dentro de una prueba

Considere esta prueba para la funci√≥n `str++_++trunc()` en stringr:

[source,r,cell-code]
----
# de stringr (hipot√©ticamente)
test_that("truncations work for all sides", {
  expect_equal(
    str_trunc("This string is moderately long", width = 20, side = "right"),
    "This string is mo..."
  )
  expect_equal(
    str_trunc("This string is moderately long", width = 20, side = "left"),
    "...s moderately long"
  )
  expect_equal(
    str_trunc("This string is moderately long", width = 20, side = "center"),
    "This stri...ely long"
  )
})
----

Hay mucha repetici√≥n aqu√≠, lo que aumenta la posibilidad de errores de copiar y pegar y, en general, hace que los ojos se pongan vidriosos. A veces es bueno crear un asistente hiperlocal, _dentro de la prueba_. As√≠ es como se ve realmente la prueba en stringr

[source,r,cell-code]
----
# de stringr (en realidad)
test_that("truncations work for all sides", {

  trunc <- function(direction) str_trunc(
    "This string is moderately long",
    direction,
    width = 20
  )

  expect_equal(trunc("right"),   "This string is mo...")
  expect_equal(trunc("left"),    "...s moderately long")
  expect_equal(trunc("center"),  "This stri...ely long")
})
----

Un asistente hiperlocal como `trunc()` es particularmente √∫til cuando le permite encajar todos los negocios importantes para cada expectativa en una l√≠nea. Luego, sus expectativas se pueden leer casi como una tabla entre lo real y lo esperado, para un conjunto de casos de uso relacionados. Arriba, es muy f√°cil ver c√≥mo cambia el resultado a medida que truncamos la entrada desde la derecha, la izquierda y el centro.

Tenga en cuenta que esta t√©cnica debe utilizarse con extrema moderaci√≥n. Un asistente como `trunc()` es otro lugar donde puedes introducir un error, por lo que es mejor mantener dichos asistentes extremadamente breves y simples.

=== Expectativas personalizadas

Si se considera necesario un ayudante m√°s complicado, es un buen momento para reflexionar sobre por qu√© es as√≠. Si es complicado ponerse en posici√≥n para _probar_ una funci√≥n, eso podr√≠a ser una se√±al de que tambi√©n es complicado _usar_ esa funci√≥n. ¬øNecesitas refactorizarlo? Si la funci√≥n parece s√≥lida, entonces probablemente necesite utilizar un asistente m√°s formal, definido fuera de cualquier prueba individual, como se describi√≥ anteriormente.

Un tipo espec√≠fico de ayuda que quiz√°s quieras crear es una expectativa personalizada. Aqu√≠ hay dos muy simples de usethis:

[source,r,cell-code]
----
expect_usethis_error <- function(...) {
  expect_error(..., class = "usethis_error")
}

expect_proj_file <- function(...) {
  expect_true(file_exists(proj_path(...)))
}
----

`expect++_++usethis++_++error()` comprueba que un error tenga la clase `"usethis++_++error"`. `expect++_++proj++_++file()` es un contenedor simple alrededor de `file++_++exists()` que busca el archivo en el proyecto actual. Son funciones muy simples, pero la gran cantidad de repeticiones y la expresividad de sus nombres las hacen sentir justificadas.

Es algo complicado crear una expectativa personalizada adecuada, es decir, una que se comporte como las expectativas integradas en testthat. Lo remitimos a la vi√±eta https://testthat.r-lib.org/articles/custom-expectation.html[Expectativas personalizadas] si desea obtener m√°s informaci√≥n al respecto.

Por √∫ltimo, puede resultar √∫til saber qu√© prueba pone a disposici√≥n informaci√≥n espec√≠fica cuando se est√° ejecutando:

* La variable de entorno `TESTTHAT` est√° establecida en `"true"`. `testthat::is++_++testing()` es un atajo:
+
[source,r,cell-code]
----
is_testing <- function() {
  Sys.getenv("TESTTHAT")
}
----
* El paquete bajo prueba est√° disponible como la variable de entorno `TESTTHAT++_++PKG` y `testthat::testing++_++package()` es un acceso directo:
+
[source,r,cell-code]
----
testing_package <- function() {
  Sys.getenv("TESTTHAT_PKG")
}
----

En algunas situaciones, es posible que desee explotar esta informaci√≥n sin depender del tiempo de ejecuci√≥n de testthat. En ese caso, simplemente inserte la fuente de estas funciones directamente en su paquete.

== Cuando las pruebas se vuelven dif√≠ciles

A pesar de todas las t√©cnicas que hemos cubierto hasta ahora, siguen existiendo situaciones en las que todav√≠a resulta muy dif√≠cil escribir pruebas. En esta secci√≥n, revisamos m√°s formas de lidiar con situaciones desafiantes:

* Saltarse una prueba en determinadas situaciones.
* Burlarse de un servicio externo.
* Lidiar con los secretos

[[tests-skipping]]
=== Saltarse una prueba

A veces es imposible realizar una prueba: es posible que no tenga conexi√≥n a Internet o que no tenga acceso a las credenciales necesarias. Desafortunadamente, otra raz√≥n probable se desprende de esta simple regla: cuantas m√°s plataformas utilice para probar su c√≥digo, m√°s probable ser√° que no pueda ejecutar todas sus pruebas, todo el tiempo. En resumen, hay ocasiones en las que, en lugar de reprobar, simplemente quieres saltarte una prueba.

==== `testthat::skip()`

Aqu√≠ usamos `testthat::skip()` para escribir un skipper personalizado hipot√©tico, `skip++_++if++_++no++_++api()`:

[source,r,cell-code]
----
skip_if_no_api() <- function() {
  if (api_unavailable()) {
    skip("API not available")
  }
}

test_that("foo api returns bar when given baz", {
  skip_if_no_api()
  ...
})
----

`skip++_++if++_++no++_++api()` es otro ejemplo m√°s de ayuda de prueba y los consejos ya dados sobre d√≥nde definirlo se aplican aqu√≠ tambi√©n.

Los `skip()` y los motivos asociados se informan en l√≠nea a medida que se ejecutan las pruebas y tambi√©n se indican claramente en el resumen:

[source,r,cell-code]
----
devtools::test()
#> ‚Ñπ Loading abcde
#> ‚Ñπ Testing abcde
#> ‚úî | F W S  OK | Context
#> ‚úî |         2 | blarg
#> ‚úî |     1   2 | foofy
#> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#> Skip (test-foofy.R:6:3): foo api returns bar when given baz
#> Reason: API not available
#> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#> ‚úî |         0 | yo                                                              
#> ‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#> ‚îÄ‚îÄ Skipped tests  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
#> ‚Ä¢ API not available (1)
#> 
#> [ FAIL 0 | WARN 0 | SKIP 1 | PASS 4 ]
#> 
#> ü•≥
----

Es probable que aparezca algo como `skip++_++if++_++no++_++api()` muchas veces en su conjunto de pruebas. Esta es otra ocasi√≥n en la que resulta tentador SECAR las cosas, elevando `skip()` al nivel superior del archivo. Sin embargo, todav√≠a nos inclinamos por llamar a `skip++_++if++_++no++_++api()` en cada prueba donde sea necesario.

[source,r,cell-code]
----
# we prefer this:
test_that("foo api returns bar when given baz", {
  skip_if_no_api()
  ...
})

test_that("foo api returns an errors when given qux", {
  skip_if_no_api()
  ...
})

# M√°s all√° de esto:
skip_if_no_api()

test_that("foo api returns bar when given baz", {...})

test_that("foo api returns an errors when given qux", {...})
----

Dentro del √°mbito del c√≥digo de nivel superior en archivos de prueba, tener un `skip()` al principio de un archivo de prueba es una de las situaciones m√°s benignas. Pero una vez que un archivo de prueba no cabe completamente en su pantalla, crea una conexi√≥n impl√≠cita pero f√°cil de pasar por alto entre `skip()` y las pruebas individuales.

==== Funciones `skip()` incorporadas

De manera similar a las expectativas integradas de test, existe una familia de funciones `skip()` que anticipan algunas situaciones comunes. Estas funciones a menudo le liberan de la necesidad de escribir un patr√≥n personalizado. A continuaci√≥n se muestran algunos ejemplos de las funciones `skip()` m√°s √∫tiles:

[source,r,cell-code]
----
test_that("foo api returns bar when given baz", {
  skip_if(api_unavailable(), "API not available")
  ...
})
test_that("foo api returns bar when given baz", {
  skip_if_not(api_available(), "API not available")
  ...
})

skip_if_not_installed("sp")
skip_if_not_installed("stringi", "1.2.2")

skip_if_offline()
skip_on_cran()
skip_on_os("windows")
----

==== Peligros de saltar

Un desaf√≠o con los saltos es que actualmente son completamente invisibles en CI: si autom√°ticamente omite demasiadas pruebas, es f√°cil enga√±arse pensando que todas sus pruebas est√°n pasando cuando en realidad simplemente se est√°n omitiendo. En un mundo ideal, su CI/CD facilitar√≠a ver cu√°ntas pruebas se omiten y c√≥mo eso cambia con el tiempo.

Es una buena pr√°ctica profundizar peri√≥dicamente en los resultados de la "`R CMD check`", especialmente en CI, y asegurarse de que los saltos sean los esperados. Pero esto tiende a ser algo que hay que aprender a trav√©s de la experiencia.

=== Mocking

La pr√°ctica conocida como mocking ocurre cuando reemplazamos algo que es complicado, poco confiable o fuera de nuestro control por algo m√°s simple, que est√° totalmente bajo nuestro control. Por lo general, se realiza mocking de un servicio externo, como una API REST, o una funci√≥n que informa algo sobre el estado de la sesi√≥n, como si la sesi√≥n es interactiva.

La aplicaci√≥n cl√°sica de mocking se encuentra en el contexto de un paquete que incluye una API externa. Para probar sus funciones, t√©cnicamente necesita realizar una llamada en vivo a esa API para obtener una respuesta, que luego procesa. Pero, ¬øqu√© pasa si esa API requiere autenticaci√≥n o si es algo inestable y tiene un tiempo de inactividad ocasional? Puede ser m√°s productivo simplemente _fingir_ llamar a la API pero, en cambio, probar el c√≥digo bajo su control procesando una respuesta pregrabada de la API real.

Nuestro principal consejo sobre realizar mocking es evitarlo si puedes. Esto no es una acusaci√≥n de mocking, sino simplemente una evaluaci√≥n realista de que realizar mocking introduce una nueva complejidad que no siempre est√° justificada por los beneficios.

Dado que la mayor√≠a de los paquetes de R no necesitan la realizaci√≥n de mocking, no lo cubrimos aqu√≠. En su lugar, le indicaremos los paquetes que representan lo √∫ltimo sobre esto en R hoy en d√≠a:

* mockery: https://github.com/r-lib/mockery
* mockr: https://krlmlr.github.io/mockr/
* httptest: https://enpiar.com/r/httptest/
* httptest2: https://enpiar.com/httptest2/
* webfakes: https://webfakes.r-lib.org

Tenga en cuenta tambi√©n que, en el momento de escribir este art√≠culo, parece probable que el paquete testthat reintroduzca algunas capacidades de mocking (despu√©s de haber salido previamente del negocio de mocking una vez). La versi√≥n v3.1.7 tiene dos nuevas funciones experimentales, `testthat::with++_++mocked++_++bindings()` y `testthat::local++_++mocked++_++bindings()`.

=== Secretos

Otro desaf√≠o com√∫n para los paquetes que incluyen un servicio externo es la necesidad de administrar las credenciales. Espec√≠ficamente, es probable que necesite proporcionar un conjunto de credenciales de prueba para probar completamente su paquete.

Nuestro principal consejo aqu√≠ es dise√±ar su paquete de modo que gran parte del mismo pueda probarse sin acceso en vivo y autenticado al servicio externo.

Por supuesto, a√∫n querr√° poder probar su paquete con el servicio real que incluye, en entornos que admitan variables de entorno seguras. Dado que este tambi√©n es un tema muy especializado, no entraremos en m√°s detalles aqu√≠. En su lugar, lo remitimos a la vi√±eta https://httr2.r-lib.org/articles/wrapping-apis.html#secret-management[API de ajuste] en el paquete httr2, que ofrece soporte sustancial para la gesti√≥n de secretos.

== Consideraciones especiales para paquetes CRAN

CRAN ejecuta `R CMD check` en todos los paquetes aportados, tanto al momento del env√≠o como de forma regular despu√©s de la aceptaci√≥n. Esta verificaci√≥n incluye, entre otras, la prueba que realiza las pruebas. Discutimos el desaf√≠o general de preparar su paquete para enfrentar todos los "`sabores`" de cheques de CRAN en <<sec-cran-flavors-services>>. Aqu√≠ nos centramos en consideraciones espec√≠ficas de CRAN para su conjunto de pruebas.

Cuando un paquete entra en conflicto con la Pol√≠tica de repositorio de CRAN (https://cran.r-project.org/web/packages/policies.html), el conjunto de pruebas suele ser el culpable (aunque no siempre). Si su paquete est√° destinado a CRAN, esto deber√≠a influir en c√≥mo escribe sus pruebas y c√≥mo (o si) se ejecutar√°n en CRAN.

[[sec-testing-advanced-skip-on-cran]]
=== Saltar una prueba

Si una prueba espec√≠fica simplemente no es apropiada para ser ejecutada por CRAN, incluya `skip++_++on++_++cran()` desde el principio.

[source,r,cell-code]
----
test_that("some long-running thing works", {
  skip_on_cran()
  # c√≥digo de prueba que potencialmente puede tardar "un tiempo" en ejecutarse  
})
----

Debajo del cap√≥, `skip++_++on++_++cran()` consulta la variable de entorno `NOT++_++CRAN`. Dicha prueba solo se ejecutar√° cuando `NOT++_++CRAN` se haya definido expl√≠citamente como `"true"`. Esta variable la establecen devtools y testthat, lo que permite que esas pruebas se ejecuten en entornos donde espera tener √©xito (y donde puede tolerar y solucionar fallas ocasionales).

En particular, los flujos de trabajo de GitHub Actions que recomendamos en <<sec-sw-dev-practices-gha>> *ejecutar√°n* pruebas con `NOT++_++CRAN = "true"`. Para ciertos tipos de funcionalidad, no existe una forma pr√°ctica de probarlas en CRAN y sus propias comprobaciones, en GitHub Actions o un servicio de integraci√≥n continua equivalente, son su mejor m√©todo de control de calidad.

Incluso hay casos raros en los que tiene sentido mantener las pruebas fuera de su paquete por completo. El equipo de tidymodels utiliza esta estrategia para pruebas de tipo integraci√≥n de todo su ecosistema que ser√≠an imposibles de alojar dentro de un paquete CRAN individual.

=== Velocidad

Sus pruebas deben ejecutarse relativamente r√°pido; idealmente, menos de un minuto en total. Utilice `skip++_++on++_++cran()` en una prueba que inevitablemente sea de larga duraci√≥n.

=== Reproducibilidad

Tenga cuidado al probar cosas que probablemente sean variables en las m√°quinas CRAN. Es arriesgado probar cu√°nto tiempo lleva algo (porque las m√°quinas CRAN a menudo est√°n muy cargadas) o probar c√≥digo paralelo (debido a que CRAN ejecuta m√∫ltiples pruebas de paquetes en paralelo, no siempre habr√° m√∫ltiples n√∫cleos disponibles). La precisi√≥n num√©rica tambi√©n puede variar entre plataformas, as√≠ que use `expect++_++equal()` a menos que tenga una raz√≥n espec√≠fica para usar `expect++_++identical()`.

[[sec-testing-advanced-flaky-tests]]
=== Pruebas inestables

Debido a la escala a la que CRAN verifica los paquetes, b√°sicamente no hay margen para una prueba que es "`simplemente inestable`", es decir, que a veces falla por razones incidentales. CRAN no procesa los resultados de las pruebas de su paquete como usted lo hace, donde puede inspeccionar cada falla y ejercer un juicio humano sobre qu√© tan preocupante es.

Probablemente sea una buena idea eliminar las pruebas inestables, ¬°s√≥lo por tu propio bien! Pero si tiene pruebas valiosas y bien escritas que son propensas a fallas molestas ocasionales, definitivamente coloque `skip++_++on++_++cran()` al principio.

El ejemplo cl√°sico es cualquier prueba que acceda a un sitio web o API web. Dado que cualquier recurso web en el mundo experimentar√° un tiempo de inactividad ocasional, es mejor no permitir que dichas pruebas se ejecuten en CRAN. La Pol√≠tica de repositorio de CRAN dice:

____
Los paquetes que utilizan recursos de Internet deber√≠an fallar elegantemente con un mensaje informativo si el recurso no est√° disponible o ha cambiado (y no dar aviso de verificaci√≥n ni error).
____

A menudo, hacer que tal falla sea "`elegante`" ir√≠a en contra del comportamiento que realmente desea en la pr√°ctica, es decir, querr√≠a que su usuario recibiera un error si su solicitud falla. Por eso suele ser m√°s pr√°ctico probar dicha funcionalidad en otro lugar.

Recuerde que las pruebas instant√°neas (<<sec-testing-basics>>), de forma predeterminada, tambi√©n se omiten en CRAN. Normalmente se utilizan estas pruebas para controlar, por ejemplo, c√≥mo se ven varios mensajes informativos. Peque√±os cambios en el formato de los mensajes son algo sobre lo que desea recibir una alerta, pero no indican un defecto importante en su paquete. Esta es la motivaci√≥n para el comportamiento predeterminado `skip++_++on++_++cran()` de las pruebas instant√°neas.

Finalmente, las pruebas inestables causan problemas a quienes mantienen sus dependencias. Cuando se actualizan los paquetes de los que depende, CRAN ejecuta `R CMD check` en todas las dependencias inversas, incluido su paquete. Si su paquete tiene pruebas inestables, su paquete puede ser la raz√≥n por la que otro paquete no pasa las comprobaciones entrantes de CRAN y puede retrasar su liberaci√≥n.

=== Higiene del sistema de archivos y procesos

En <<sec-tests-files-where-write>>, le instamos a que escriba √∫nicamente en el directorio temporal de la sesi√≥n y que limpie lo que haya dejado usted mismo. Esta pr√°ctica hace que su conjunto de pruebas sea mucho m√°s f√°cil de mantener y predecible. Para los paquetes que est√°n (o aspiran a estar) en CRAN, esto es absolutamente necesario seg√∫n la pol√≠tica del repositorio de CRAN:

____
Los paquetes no deben escribirse en el espacio de archivos de inicio del usuario (incluidos los portapapeles), ni en ning√∫n otro lugar del sistema de archivos aparte del directorio temporal de la sesi√≥n R (o durante la instalaci√≥n en la ubicaci√≥n se√±alada por TMPDIR: y dicho uso debe limpiarse). ‚Ä¶ Se pueden permitir excepciones limitadas en sesiones interactivas si el paquete obtiene la confirmaci√≥n del usuario.
____

Del mismo modo, debes esforzarte en ser higi√©nico con respecto a cualquier proceso que inicies:

____
Los paquetes no deben iniciar software externo (como visores o navegadores de PDF) durante los ejemplos o pruebas a menos que esa instancia espec√≠fica del software se cierre expl√≠citamente despu√©s.
____

Acceder al portapapeles es la tormenta perfecta que potencialmente entra en conflicto con ambas pautas, ya que el portapapeles se considera parte del espacio de archivos de inicio del usuario y, en Linux, puede iniciar un proceso externo (por ejemplo, xsel o xclip). Por lo tanto, es mejor desactivar cualquier funcionalidad del portapapeles en sus pruebas (y asegurarse de que, durante el uso aut√©ntico, su usuario claramente opte por ello).

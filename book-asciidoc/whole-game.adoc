[[sec-whole-game]]
= Todo el juego
:description: Aprenda a crear un paquete, la unidad fundamental de contenido compartible, reutilizable, y c√≥digo R reproducible.
:lang: es

_¬°Alerta de spoiler!_

Este cap√≠tulo recorre el desarrollo de un peque√±o paquete de juguete. Su objetivo es pintar el panorama general y sugerir un flujo de trabajo, antes de pasar al tratamiento detallado de los componentes clave de un paquete R.

Para mantener el ritmo r√°pido, aprovechamos las comodidades modernas del paquete devtools y el IDE de RStudio. En cap√≠tulos posteriores, seremos m√°s expl√≠citos acerca de lo que esos ayudantes est√°n haciendo por nosotros.

Este cap√≠tulo es independiente, ya que completar el ejercicio no es un requisito estricto para continuar con el resto del libro; sin embargo, le sugerimos encarecidamente que lo siga y cree este paquete de juguete con nosotros.

== Cargar devtools y amigos

Puede iniciar su nuevo paquete desde cualquier sesi√≥n de R activa. No necesita preocuparse por si est√° en un proyecto nuevo o existente o no. Las funciones que utilizamos garantizan que creemos un nuevo proyecto limpio para el paquete.

Cargue el paquete devtools, que es la cara p√∫blica de un conjunto de paquetes que admiten varios aspectos del desarrollo de paquetes. El m√°s obvio de ellos es el paquete usethis, que ver√° que tambi√©n se est√° cargando.

[source,r,cell-code]
----
library(devtools)
#> Loading required package: usethis
----

¬øTienes una versi√≥n antigua de devtools? Compare su versi√≥n con la nuestra y actual√≠cela si es necesario.

[source,r,cell-code]
----
packageVersion("devtools")
#> [1] '2.4.5'
----

== Paquete de juguete: regexcite

Para ayudarle a trav√©s del proceso, utilizamos varias funciones de devtools para crear un peque√±o paquete de juguete desde cero, con caracter√≠sticas que se ven com√∫nmente en los paquetes lanzados:

* Funciones para abordar una necesidad espec√≠fica, en este caso ayudantes para trabajar con expresiones regulares.
* Control de versiones y proceso de desarrollo abierto.
** Esto es completamente opcional en tu trabajo, pero muy recomendable. Ver√°s c√≥mo Git y GitHub nos ayudan a exponer todas las etapas intermedias de nuestro paquete de juguete.
* Acceso a flujos de trabajo establecidos para instalaci√≥n, obtenci√≥n de ayuda y verificaci√≥n de calidad.
** Documentaci√≥n para funciones individuales mediante https://roxygen2.r-lib.org[roxygen2].
** Pruebas unitarias con https://testthat.r-lib.org[testthat].
** Documentaci√≥n del paquete en su conjunto a trav√©s de un ejecutable. `README.Rmd`.

Llamamos al paquete *regexcite* y contiene un par de funciones que facilitan las tareas comunes con expresiones regulares. Tenga en cuenta que estas funciones son muy simples y solo las utilizamos aqu√≠ como medio para guiarlo a trav√©s del proceso de desarrollo del paquete. Si est√° buscando ayudas reales para trabajar con expresiones regulares, existen varios paquetes de R adecuados que abordan este espacio problem√°tico:

* https://stringr.tidyverse.org[stringr] (which uses stringi)
* https://stringi.gagolewski.com/[stringi]
* https://cran.r-project.org/package=rex[rex]
* https://cran.r-project.org/package=rematch2[rematch2]

Nuevamente, el paquete regexcite en s√≠ es solo un dispositivo para demostrar un flujo de trabajo t√≠pico para el desarrollo de paquetes con devtools.

== Vista previa del producto terminado

Se realiza un seguimiento del paquete regexcite durante su desarrollo con el sistema de control de versiones Git. Esto es puramente opcional y ciertamente puede seguirlo sin implementarlo. Un buen beneficio adicional es que eventualmente lo conectamos a un repositorio remoto en GitHub, lo que significa que puedes ver el glorioso resultado por el que estamos trabajando visitando regexcite en GitHub: https://github.com/jennybc/regexcite. Al inspeccionar el https://github.com/jennybc/regexcite/commits/main[commit history] y especialmente las diferencias, puedes ver exactamente qu√© cambios en cada paso del proceso que se detalla a continuaci√≥n.

== `create++_++package()`

Llame a `create++_++package()` para inicializar un nuevo paquete en un directorio de su computadora. `create++_++package()` crear√° autom√°ticamente ese directorio si a√∫n no existe (y ese suele ser el caso). Consulte <<sec-workflow101-create-package>> para obtener m√°s informaci√≥n sobre la creaci√≥n de paquetes.

Elija deliberadamente d√≥nde crear este paquete en su computadora. Probablemente deber√≠a estar en alg√∫n lugar de su directorio de inicio, junto con sus otros proyectos de R. No debe estar anidado dentro de otro proyecto RStudio, paquete R o repositorio Git. Tampoco deber√≠a estar en una biblioteca de paquetes de R, que contiene paquetes que ya han sido creados e instalados. La conversi√≥n del paquete fuente que creamos aqu√≠ en un paquete instalado es parte de lo que facilita devtools. ¬°No intentes hacer el trabajo de devtools por el!

Una vez que haya seleccionado d√≥nde crear este paquete, sustituya la ruta elegida por una llamada `create++_++package()` como esta:

[source,r,cell-code]
----
create_package("~/path/to/regexcite")
----

Para la creaci√≥n de este libro tenemos que trabajar en un directorio temporal, porque el libro est√° construido de forma no interactiva en la nube. Detr√°s de escena, estamos ejecutando nuestro propio comando `create++_++package()`, pero no te sorprendas si nuestra salida difiere un poco de la tuya.

....
#> ‚úî Creating '/tmp/RtmpJR4gjQ/regexcite/'
#> ‚úî Setting active project to '/tmp/RtmpJR4gjQ/regexcite'
#> ‚úî Creating 'R/'
#> ‚úî Writing 'DESCRIPTION'
#> Package: regexcite
#> Title: What the Package Does (One Line, Title Case)
#> Version: 0.0.0.9000
#> Authors@R (parsed):
#>     * First Last <first.last@example.com> [aut, cre] (YOUR-ORCID-ID)
#> Description: What the package does (one paragraph).
#> License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
#>     license
#> Encoding: UTF-8
#> Roxygen: list(markdown = TRUE)
#> RoxygenNote: 7.3.1
#> ‚úî Writing 'NAMESPACE'
#> ‚úî Writing 'regexcite.Rproj'
#> ‚úî Adding '^regexcite\\.Rproj$' to '.Rbuildignore'
#> ‚úî Adding '.Rproj.user' to '.gitignore'
#> ‚úî Adding '^\\.Rproj\\.user$' to '.Rbuildignore'
#> ‚úî Setting active project to '<no active project>'
....

Si est√° trabajando en RStudio, deber√≠a encontrarse en una nueva instancia de RStudio, abierta en su nuevo paquete regexcite (y Proyecto). Si de alguna manera necesita hacer esto manualmente, navegue hasta el directorio y haga doble clic en `regexcite.Rproj`. RStudio tiene un manejo especial para paquetes y ahora deber√≠a ver una pesta√±a _Build_ en el mismo panel que _Environment_ e _History_.

Probablemente necesites llamar a `library(devtools)` nuevamente, porque `create++_++package()` probablemente te haya llevado a una nueva sesi√≥n de R, en tu nuevo paquete.

[source,r,cell-code]
----
library(devtools)
----

¬øQu√© hay en este nuevo directorio que tambi√©n es un paquete R y, probablemente, un proyecto RStudio? Aqu√≠ hay una lista (localmente, puede consultar su panel _Files_):

[cols="<,<",options="header",]
|===
|path |type
|.Rbuildignore |file
|.gitignore |file
|DESCRIPTION |file
|NAMESPACE |file
|R |directory
|regexcite.Rproj |file
|===

[TIP]
.RStudio
====
En el panel _Files_, vaya a _More (s√≠mbolo de engranaje) ++>++ Show Hidden Files_ para alternar la visibilidad de archivos ocultos (a.k.a. https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory#Unix_and_Unix-like_environments["`dotfiles`"]). Unos pocos seleccionados est√°n visibles todo el tiempo, pero a veces quieres verlos todos.
====

* `.Rbuildignore` enumera los archivos que necesitamos tener a mano pero que no deben incluirse al crear el paquete R desde el c√≥digo fuente. Si no est√° utilizando RStudio, es posible que `create++_++package()` no cree este archivo (ni tampoco `.gitignore`) al principio, ya que no hay ninguna maquinaria relacionada con RStudio que deba ignorarse. Sin embargo, es probable que en alg√∫n momento desarrolle la necesidad de `.Rbuildignore`, independientemente del editor que est√© utilizando. Se analiza con m√°s detalle en <<sec-rbuildignore>>.
* `.Rproj.user`, si lo tiene, es un directorio utilizado internamente por RStudio.
* `.gitignore` anticipa el uso de Git y le dice a Git que ignore algunos archivos est√°ndar detr√°s de escena creados por R y RStudio. Incluso si no planeas usar Git, esto es inofensivo.
* `DESCRIPTION` proporciona metadatos sobre su paquete. Editaremos esto en breve y <<sec-description>> cubre el tema general del archivo `DESCRIPTION`.
* `NAMESPACE` declara las funciones que su paquete exporta para uso externo y las funciones externas que su paquete importa de otros paquetes. En este punto, est√° vac√≠o, excepto por un comentario que declara que este es un archivo que no debes editar a mano.
* El directorio `R/` es el "`final comercial`" de su paquete. Pronto contendr√° archivos `.R` con definiciones de funciones.
* `regexcite.Rproj` es el archivo que convierte este directorio en un proyecto RStudio. Incluso si no utiliza RStudio, este archivo es inofensivo. O puede suprimir su creaci√≥n con `create++_++package(..., rstudio = FALSE)`. M√°s en <<sec-workflow101-rstudio-projects>>.

== `use++_++git()`

El directorio regexcite es un paquete fuente de R y un proyecto RStudio. Ahora lo convertimos tambi√©n en un repositorio Git, con `use++_++git()`. (Por cierto, `use++_++git()` funciona en cualquier proyecto, independientemente de si es un paquete R).

[source,r,cell-code]
----
use_git()
#> ‚úî Initialising Git repo
#> ‚úî Adding '.Rhistory', '.Rdata', '.httr-oauth', '.DS_Store', '.quarto' to '.gitignore'
----

En una sesi√≥n interactiva, se le preguntar√° si desea enviar algunos archivos aqu√≠ y deber√° aceptar la oferta. Detr√°s de escena, tambi√©n enviaremos esos mismos archivos.

Entonces, ¬øqu√© ha cambiado en el paquete? S√≥lo la creaci√≥n de un directorio `.git`, que est√° oculto en la mayor√≠a de los contextos, incluido el explorador de archivos RStudio. Su existencia es evidencia de que efectivamente hemos inicializado un repositorio de Git aqu√≠.

[cols="<,<",options="header",]
|===
|path |type
|.git |directory
|===

Si est√° utilizando RStudio, probablemente solicit√≥ permiso para reiniciarse en este proyecto, lo cual deber√≠a hacer. Puede hacerlo manualmente saliendo y luego reiniciando RStudio haciendo doble clic en `regexcite.Rproj`. Ahora, adem√°s del soporte para el desarrollo de paquetes, tiene acceso a un cliente Git b√°sico en la pesta√±a _Git_ del panel _Environment/History/Build_.

Haga clic en Historial (el √≠cono del reloj en el panel de Git) y, si dio su consentimiento, ver√° una confirmaci√≥n inicial realizada a trav√©s de `use++_++git()`:

[width="100%",cols="<14%,<71%,<15%",options="header",]
|===
|commit |author |message
|0dfb94f384‚Ä¶ |Quarto GHA Workflow Runner quarto-github-actions-publish@example.com |Initial commit
|===

[TIP]
.RStudio
====
RStudio puede inicializar un repositorio Git, en cualquier proyecto, incluso si no es un paquete R, siempre que haya configurado la integraci√≥n de RStudio {plus} Git. Hacer _Tools ++>++ Version Control ++>++ Project Setup_. Entonces seleccione _Version control system: Git_ y _initialize a new git repository for this project_.
====

== Escribe la primera funci√≥n.

Una tarea bastante com√∫n cuando se trata de cadenas es la necesidad de dividir una √∫nica cadena en muchas partes. La funci√≥n `strsplit()` en base R hace exactamente esto.

[source,r,cell-code]
----
(x <- "alfa,bravo,charlie,delta")
#> [1] "alfa,bravo,charlie,delta"
strsplit(x, split = ",")
#> [[1]]
#> [1] "alfa"    "bravo"   "charlie" "delta"
----

Observe de cerca el valor de retorno.

[source,r,cell-code]
----
str(strsplit(x, split = ","))
#> List of 1
#>  $ : chr [1:4] "alfa" "bravo" "charlie" "delta"
----

La forma de este valor de retorno a menudo sorprende a la gente o, al menos, les incomoda. La entrada es un vector de caracteres de longitud uno y la salida es una lista de longitud uno. Esto tiene mucho sentido a la luz de la tendencia fundamental de R hacia la vectorizaci√≥n. Pero a veces sigue siendo un poco fastidioso. A menudo sabes que tu entrada es moralmente un escalar, es decir, es solo una cadena y realmente quieres que la salida sea el vector de caracteres de sus partes.

Esto lleva a los usuarios de R a emplear varios m√©todos para "`deslistar`" el resultado:

[source,r,cell-code]
----
unlist(strsplit(x, split = ","))
#> [1] "alfa"    "bravo"   "charlie" "delta"

strsplit(x, split = ",")[[1]]
#> [1] "alfa"    "bravo"   "charlie" "delta"
----

La segunda soluci√≥n, m√°s segura, es la base para la funci√≥n inaugural de regexcite: `strsplit1()`.

[source,r,r,cell-code]
----
strsplit1 <- function(x, split) {
  strsplit(x, split = split)[[1]]
}
----

Este libro no le ense√±a c√≥mo escribir funciones en R. Para obtener m√°s informaci√≥n al respecto, eche un vistazo a https://r4ds.hadley.nz/functions.html[Cap√≠tulo de funciones] de R para Ciencia de Datos y el https://adv-r.hadley.nz/functions.html[Cap√≠tulo de funciones] de R Avanzado.

[TIP]
====
El nombre de `strsplit1()` es un gui√±o al muy √∫til `paste0()`, que apareci√≥ por primera vez en R 2.15.0 en 2012. `paste0()` fue creado para abordar el caso de uso extremadamente com√∫n de pegar - unir cadenas _sin_ un separador. `paste0()` ha sido descrito cari√±osamente como https://simplystatistics.org/posts/2013-01-31-paste0-is-statistical-computings-most-influential-contribution-of-the-21st-century/["`la contribuci√≥n m√°s influyente de la inform√°tica estad√≠stica del siglo XXI`"].

La funci√≥n `strsplit1()` fue tan inspiradora que ahora es una funci√≥n real en el paquete stringr: `stringr::str++_++split++_++1()`!

====

== `use++_++r()`

¬øD√≥nde deber√≠as poner la definici√≥n de `strsplit1()`? Gu√°rdelo en un archivo `.R`, en el subdirectorio `R/` de su paquete. Una posici√≥n inicial razonable es crear un nuevo archivo `.R` para cada funci√≥n orientada al usuario en su paquete y nombrar el archivo despu√©s de la funci√≥n. A medida que agregue m√°s funciones, querr√° relajar esto y comenzar a agrupar funciones relacionadas. Guardaremos la definici√≥n de `strsplit1()` en el archivo `R/strsplit1.R`.

El asistente `use++_++r()` crea y/o abre un script debajo de `R/`. Realmente brilla en un paquete m√°s maduro, cuando se navega entre archivos `.R` y el archivo de prueba asociado. Pero incluso en este caso es √∫til evitar dejarse llevar demasiado mientras se trabaja en `Untitled4`.

[source,r,cell-code]
----
use_r("strsplit1")
#> ‚Ä¢ Edit 'R/strsplit1.R'
----

Coloque la definici√≥n de `strsplit1()` *y solo la definici√≥n de `strsplit1()`* en `R/strsplit1.R` y gu√°rdela. El archivo `R/strsplit1.R` NO debe contener ning√∫n otro c√≥digo de nivel superior que hayamos ejecutado recientemente, como la definici√≥n de nuestra entrada de pr√°ctica `x`, `library(devtools)` o `use++_++git()` . Esto presagia un ajuste que deber√° realizar a medida que pasa de escribir scripts R a paquetes R. Los paquetes y scripts utilizan diferentes mecanismos para declarar su dependencia de otros paquetes y almacenar c√≥digo de ejemplo o de prueba. Exploramos esto m√°s a fondo en <<sec-r>>.

[[sec-whole-game-load-all]]
== `load++_++all()`

¬øC√≥mo probamos `strsplit1()`? Si se tratara de un script R normal, podr√≠amos usar RStudio para enviar la definici√≥n de la funci√≥n a la Consola R y definir `strsplit1()` en el entorno global. O tal vez llamar√≠amos `source ("R/strsplit1.R")`. Sin embargo, para el desarrollo de paquetes, devtools ofrece un enfoque m√°s s√≥lido.

Llame a `load++_++all()` para que `strsplit1()` est√© disponible para la experimentaci√≥n.

[source,r,cell-code]
----
load_all()
#> ‚Ñπ Loading regexcite
----

Ahora llame a `strsplit1(x)` para ver c√≥mo funciona.

[source,r,cell-code]
----
(x <- "alfa,bravo,charlie,delta")
#> [1] "alfa,bravo,charlie,delta"
strsplit1(x, split = ",")
#> [1] "alfa"    "bravo"   "charlie" "delta"
----

Tenga en cuenta que `load++_++all()` ha hecho que la funci√≥n `strsplit1()` est√© disponible, aunque no existe en el entorno global.

[source,r,cell-code]
----
exists("strsplit1", where = globalenv(), inherits = FALSE)
#> [1] FALSE
----

Si ve `TRUE` en lugar de `FALSE`, eso indica que todav√≠a est√° utilizando un flujo de trabajo orientado a secuencias de comandos y obteniendo sus funciones. A continuaci√≥n le indicamos c√≥mo volver a la normalidad:

* Limpie el entorno global y reinicie R.
* Vuelva a adjuntar devtools con `library(devtools)` y vuelva a cargar regexcite con `load++_++all()`.
* Redefina la entrada de prueba `x` y llame a `strsplit1(x, split = ",")` nuevamente. ¬°Esto deber√≠a funcionar!
* Ejecute `exists("strsplit1", donde = globalenv(), hereda = FALSE)` nuevamente y deber√≠a ver `FALSE`.

`load++_++all()` Simula el proceso de construcci√≥n, instalaci√≥n y conexi√≥n del paquete regexcite. A medida que su paquete acumula m√°s funciones, algunas exportadas, otras no, algunas de las cuales se llaman entre s√≠, algunas de las cuales llaman a funciones de paquetes de los que depende, `load++_++all()` le brinda una idea mucho m√°s precisa de c√≥mo se est√° desarrollando el paquete que funciones de conducci√≥n de prueba definidas en el entorno global. Adem√°s, `load++_++all()` permite una iteraci√≥n mucho m√°s r√°pida que construir, instalar y adjuntar el paquete. Consulte <<sec-workflow101-load-all>> para obtener m√°s informaci√≥n sobre `load++_++all()`.

Para revisar lo que hemos hecho hasta ahora:

* Escribimos nuestra primera funci√≥n, `strsplit1()`, para dividir una cadena en un vector de caracteres (no una lista que contenga un vector de caracteres).
* Usamos `load++_++all()` para hacer que esta funci√≥n est√© disponible r√°pidamente para uso interactivo, como si hubi√©ramos creado e instalado regexcite y lo hubi√©ramos adjuntado a trav√©s de `library(regexcite)`.

[TIP]
.RStudio
====
RStudio expone `load++_++all()` en el menu _Build_, en el panel _Build_ via _More ++>++ Load All_, y en atajos de teclado Ctrl {plus} Shift {plus} L (Windows & Linux) o Cmd {plus} Shift {plus} L (macOS).
====

=== Commit `strsplit1()`

Si est√°s usando Git, usa tu m√©todo preferido para enviar el nuevo archivo `R/strsplit1.R`. Lo hacemos detr√°s de escena aqu√≠ y aqu√≠ est√° la diferencia asociada.

....
diff --git a/R/strsplit1.R b/R/strsplit1.R
new file mode 100644
index 0000000..29efb88
--- /dev/null
+++ b/R/strsplit1.R
@@ -0,0 +1,3 @@
+strsplit1 <- function(x, split) {
+  strsplit(x, split = split)[[1]]
+}
....

A partir de este momento, realizaremos un commit despu√©s de cada paso. Recuerda https://github.com/jennybc/regexcite/commits/main[estos commits] est√°n disponibles en el repositorio p√∫blico.

== `check()`

Tenemos evidencia emp√≠rica e informal de que `strsplit1()` funciona. Pero, ¬øc√≥mo podemos estar seguros de que todas las partes m√≥viles del paquete regexcite siguen funcionando? Puede parecer una tonter√≠a comprobarlo despu√©s de una adici√≥n tan peque√±a, pero es bueno establecer el h√°bito de comprobarlo con frecuencia.

`R CMD check`, ejecutado en el shell, es el est√°ndar de oro para comprobar que un paquete R est√° en pleno funcionamiento. `check()` es una forma conveniente de ejecutar esto sin salir de la sesi√≥n de R.

Tenga en cuenta que `check()` produce una salida bastante voluminosa, optimizada para el consumo interactivo. Lo interceptamos aqu√≠ y solo revelamos un resumen. Su salida local `check()` ser√° diferente.

[source,r,cell-code]
----
check()
----

....
‚îÄ‚îÄ R CMD check results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ regexcite 0.0.0.9000 ‚îÄ‚îÄ‚îÄ‚îÄ
Duration: 5.5s

‚ùØ checking DESCRIPTION meta-information ... WARNING
  Non-standard license specification:
    `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license
  Standardizable: FALSE

0 errors ‚úî | 1 warning ‚úñ | 0 notes ‚úî
....

_¬°Es esencial leer realmente el resultado del cheque!_ Aborde los problemas tempranamente y con frecuencia. Es como el desarrollo incremental de archivos `.R` y `.Rmd`. Cuanto m√°s tiempo pase entre comprobaciones completas de que todo funciona, m√°s dif√≠cil ser√° identificar y resolver sus problemas.

En este punto, esperamos 1 advertencia (y 0 errores, 0 notas):

....
Non-standard license specification:
  `use_mit_license()`, `use_gpl3_license()` or friends to pick a
  license
....

Abordaremos eso pronto, haciendo exactamente lo que dice. Puedes aprender m√°s sobre `check()` en <<sec-workflow101-r-cmd-check>>.

[TIP]
.RStudio
====
RStudio expone `check()` en el men√∫ _Build_, en el panel _Build_ a trav√©s de _Check_ y en los atajos de teclado Ctrl {plus} Shift {plus} E (Windows & Linux) o Cmd {plus} Shift {plus} E (macOS).
====

== Editar `DESCRIPTION`

El archivo `DESCRIPTION` proporciona metadatos sobre su paquete y se trata completamente en <<sec-description>>. Este es un buen momento para echar un vistazo a la descripci√≥n actual de regexcite. Ver√° que est√° lleno de contenido repetitivo, que debe ser reemplazado.

Para agregar sus propios metadatos, realice estas ediciones:

* Convi√©rtete en el autor. Si no tiene un ORCID, puede omitir la parte `coment = ...`.
* Escriba un texto descriptivo en los campos `Title` y `Description`.

[TIP]
.RStudio
====
Use Ctrl {plus} `.` en RStudio y comienza a escribir "`DESCRIPTION`" para activar un asistente que facilita la apertura de un archivo para editarlo. Adem√°s de un nombre de archivo, su sugerencia puede ser el nombre de una funci√≥n. Esto es muy √∫til cuando un paquete tiene muchos archivos.
====

Cuando termines, `DESCRIPTION` deber√≠a verse similar a esto:

[source,text,text,cell-code]
----
Package: regexcite
Title: Haga que las expresiones regulares sean m√°s emocionantes
Version: 0.0.0.9000
Authors@R: 
    person("Jane", "Doe", , "jane@example.com", role = c("aut", "cre"))
Description: Funciones convenientes para facilitar un poco algunas tareas
    comunes con manipulaci√≥n de cadenas y expresiones regulares.
License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.1.2
----

== `use++_++mit++_++license()`

____
https://blog.codinghorror.com/pick-a-license-any-license/[Elija una licencia&#44; cualquier licencia. ‚Äì Jeff Atwood]
____

Actualmente tenemos un marcador de posici√≥n en el campo `License` de `DESCRIPTION` que es deliberadamente inv√°lido y sugiere una soluci√≥n.

....
License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license
....

Para configurar una licencia v√°lida para el paquete, llame `use++_++mit++_++license()`.

[source,r,cell-code]
----
use_mit_license()
#> ‚úî Adding 'MIT + file LICENSE' to License
#> ‚úî Writing 'LICENSE'
#> ‚úî Writing 'LICENSE.md'
#> ‚úî Adding '^LICENSE\\.md$' to '.Rbuildignore'
----

Esto configura correctamente el campo `License` para la licencia MIT, que promete nombrar a los titulares de los derechos de autor y el a√±o en un archivo `LICENSE`. Abra el archivo `LICENSE` reci√©n creado y confirme que se ve as√≠:

....
YEAR: 2025
COPYRIGHT HOLDER: regexcite authors
....

Al igual que otros asistentes de licencia, `use++_++mit++_++license()` tambi√©n coloca una copia de la licencia completa en `LICENSE.md` y agrega este archivo a `.Rbuildignore`. Se considera una buena pr√°ctica incluir una licencia completa en el c√≥digo fuente de su paquete, como en GitHub, pero CRAN no permite la inclusi√≥n de este archivo en un paquete. Puede obtener m√°s informaci√≥n sobre las licencias en <<sec-license>>.

[[sec-whole-game-document]]
== `document()`

¬øNo ser√≠a bueno recibir ayuda sobre `strsplit1()`, tal como lo hacemos con otras funciones de R? Esto requiere que su paquete tenga un archivo de documentaci√≥n R especial, `man/strsplit1.Rd`, escrito en un lenguaje de marcado espec√≠fico de R que es algo as√≠ como LaTeX. Afortunadamente, no necesariamente tenemos que crear eso directamente.

Escribimos un comentario con formato especial justo encima de `strsplit1()`, en su archivo fuente, y luego dejamos que un paquete llamado https://roxygen2.r-lib.org[roxygen2] manejar la creaci√≥n de `man/strsplit1.Rd`. La motivaci√≥n y la mec√°nica de roxygen2 se tratan en <<sec-man>>.

Si usa RStudio, abra `R/strsplit1.R` en el editor de c√≥digo fuente y coloque el cursor en alg√∫n lugar de la definici√≥n de la funci√≥n `strsplit1()`. Ahora haz _Code ++>++ Insert roxygen skeleton_. Deber√≠a aparecer un comentario muy especial encima de tu funci√≥n, en el que cada l√≠nea comienza con `#'`. RStudio solo inserta una plantilla b√°sica, por lo que deber√° editarla para que se vea as√≠ a continuaci√≥n.

Si no utiliza RStudio, cree el comentario usted mismo. De todos modos, debes modificarlo para que se vea as√≠:

[source,r,r,cell-code]
----
#' dividir una cadena de caracteres
#'
#' @param x Un vector de caracteres con un elemento..
#' @param split En qu√© dividirse.
#'
#' @return Un vector de caracteres.
#' @export
#'
#' @examples
#' x <- "alfa,bravo,charlie,delta"
#' strsplit1(x, split = ",")
strsplit1 <- function(x, split) {
  strsplit(x, split = split)[[1]]
}
----

¬°Pero a√∫n no hemos terminado! Todav√≠a tenemos que activar la conversi√≥n de este nuevo comentario de roxygen en `man/strsplit1.Rd` con `document()`:

[source,r,cell-code]
----
document()
#> ‚Ñπ Updating regexcite documentation
#> Setting `RoxygenNote` to "7.3.1"
#> ‚Ñπ Loading regexcite
#> Writing 'NAMESPACE'
#> Writing 'strsplit1.Rd'
----

[TIP]
.RStudio
====
RStudio expone `document()` en el men√∫ _Build_, en el panel _Build_ a trav√©s de _More ++>++ Document_ y con atajos de teclado Ctrl {plus} Shift {plus} D (Windows & Linux) o Cmd {plus} Shift {plus} D (macOS).
====

Ahora deber√≠a poder obtener una vista previa de su archivo de ayuda de esta manera:

[source,r,cell-code]
----
?strsplit1
----

Ver√°s un mensaje como "`Rendering development documentation for '`strsplit1`'`", lo que recuerda que b√°sicamente est√° obteniendo una vista previa del borrador de la documentaci√≥n. Es decir, esta documentaci√≥n est√° presente en el c√≥digo fuente de su paquete, pero a√∫n no est√° presente en un paquete instalado. De hecho, todav√≠a no hemos instalado regexcite, pero lo haremos pronto. Si `?strsplit1` no funciona para usted, es posible que deba llamar a `load++_++all()` primero y luego intentarlo nuevamente.

Tenga en cuenta tambi√©n que la documentaci√≥n de su paquete no se conectar√° correctamente hasta que se haya construido e instalado formalmente. Esto elimina detalles como los enlaces entre archivos de ayuda y la creaci√≥n de un √≠ndice de paquetes.

=== `NAMESPACE` cambios

Adem√°s de convertir el comentario especial de `strsplit1()` en `man/strsplit1.Rd`, la llamada a `document()` actualiza el archivo `NAMESPACE`, bas√°ndose en las etiquetas `@export` que se encuentran en los comentarios de roxygen. Abra `NAMESPACE` para su inspecci√≥n. Los contenidos deben ser:

....
# Generated by roxygen2: do not edit by hand

export(strsplit1)
....

La directiva de exportaci√≥n en `NAMESPACE` es lo que hace que `strsplit1()` est√© disponible para un usuario despu√©s de adjuntar regexcite a trav√©s de `library(regexcite)`. As√≠ como es completamente posible crear archivos `.Rd` "`a mano`", puedes administrar `NAMESPACE` expl√≠citamente t√∫ mismo. Pero elegimos delegar esto a devtools (y a roxygen2).

== `check()` de nuevo

regexcite deber√≠a pasar la `R CMD check` limpiamente ahora y para siempre: 0 errores, 0 advertencias, 0 notas.

[source,r,cell-code]
----
check()
----

....
‚îÄ‚îÄ R CMD check results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ regexcite 0.0.0.9000 ‚îÄ‚îÄ‚îÄ‚îÄ
Duration: 7.1s

0 errors ‚úî | 0 warnings ‚úî | 0 notes ‚úî
....

== `install()`

Ahora que sabemos que tenemos un producto m√≠nimo viable, instalemos el paquete regexcite en su biblioteca mediante `install()`:

[source,r,cell-code]
----
install()
----

....
‚îÄ‚îÄ R CMD build ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
* checking for file ‚Äò/tmp/RtmpJR4gjQ/regexcite/DESCRIPTION‚Äô ... OK
* preparing ‚Äòregexcite‚Äô:
* checking DESCRIPTION meta-information ... OK
* checking for LF line-endings in source and make files and shell scripts
* checking for empty or unneeded directories
* building ‚Äòregexcite_0.0.0.9000.tar.gz‚Äô
Running /opt/R/4.4.0/lib/R/bin/R CMD INSTALL \
  /tmp/RtmpJR4gjQ/regexcite_0.0.0.9000.tar.gz --install-tests 
* installing to library ‚Äò/home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu‚Äô
* installing *source* package ‚Äòregexcite‚Äô ...
** using staged installation
** R
** byte-compile and prepare package for lazy loading
** help
*** installing help indices
** building package indices
** testing if installed package can be loaded from temporary location
** testing if installed package can be loaded from final location
** testing if installed package keeps a record of temporary installation path
* DONE (regexcite)
....

[TIP]
.RStudio
====
RStudio expone una funcionalidad similar en el menu _Build_ y en el panel _Build_ via _Install and Restart_, y con atajos de teclado Ctrl {plus} Shift {plus} B (Windows & Linux) o Cmd {plus} Shift {plus} B (macOS).
====

Una vez completada la instalaci√≥n, podemos adjuntar y usar regexcite como cualquier otro paquete. Revisemos nuestro peque√±o ejemplo desde arriba. Este tambi√©n es un buen momento para reiniciar su sesi√≥n de R y asegurarse de tener un espacio de trabajo limpio.

[source,r,cell-code]
----
library(regexcite)

x <- "alfa,bravo,charlie,delta"
strsplit1(x, split = ",")
#> [1] "alfa"    "bravo"   "charlie" "delta"
----

¬°√âxito!

== `use++_++testthat()`

Hemos probado `strsplit1()` de manera informal, en un solo ejemplo. Podemos formalizar esto como una prueba unitaria. Esto significa que expresamos una expectativa concreta sobre el resultado correcto de `strsplit1()` para una entrada espec√≠fica.

Primero, declaramos nuestra intenci√≥n de escribir pruebas unitarias y usar el paquete testthat para esto, a trav√©s de `use++_++testthat()`:

[source,r,cell-code]
----
use_testthat()
#> ‚úî Adding 'testthat' to Suggests field in DESCRIPTION
#> ‚úî Adding '3' to Config/testthat/edition
#> ‚úî Creating 'tests/testthat/'
#> ‚úî Writing 'tests/testthat.R'
#> ‚Ä¢ Call `use_test()` to initialize a basic test file and open it for editing.
----

Esto inicializa la maquinaria de prueba unitaria para su paquete. A√±ade `Suggests: testthat` a `DESCRIPTION`, crea el directorio `tests/testthat/`, y a√±ade el script `tests/testthat.R`. Notar√°s que la prueba probablemente se agreg√≥ con una versi√≥n m√≠nima de 3.0.0 y un segundo campo DESCRIPTION, `Config/testthat/edition: 3`. Hablaremos m√°s sobre esos detalles en <<sec-testing-basics>>.

Sin embargo, ¬°todav√≠a depende de USTED escribir las pruebas reales!

El asistente `use++_++test()` abre y/o crea un archivo de prueba. Puede proporcionar el nombre base del archivo o, si est√° editando el archivo fuente relevante en RStudio, se generar√° autom√°ticamente. Para muchos de ustedes, si `R/strsplit1.R` es el archivo activo en RStudio, pueden simplemente llamar a `use++_++test()`. Sin embargo, dado que este libro no se cre√≥ de forma interactiva, debemos proporcionar el nombre base de forma expl√≠cita:

[source,r,cell-code]
----
use_test("strsplit1")
#> ‚úî Writing 'tests/testthat/test-strsplit1.R'
#> ‚Ä¢ Edit 'tests/testthat/test-strsplit1.R'
----

Esto crea el archivo `tests/testthat/test-strsplit1.R`. Si ya hubiera existido, `use++_++test()` simplemente lo habr√≠a abierto. Notar√°s que hay una prueba de ejemplo en el archivo reci√©n creado; elimina ese c√≥digo y reempl√°zalo con este contenido:

[source,r,r,cell-code]
----
test_that("strsplit1() splits a string", {
  expect_equal(strsplit1("a,b,c", split = ","), c("a", "b", "c"))
})
----

Esto prueba que `strsplit1()` da el resultado esperado al dividir una cadena de caracteres.

Ejecute esta prueba de forma interactiva, como lo har√° cuando escriba la suya propia. Si no se puede encontrar `test++_++that()` o `strsplit1()`, eso sugiere que probablemente necesites llamar a `load++_++all()`.

En el futuro, sus pruebas se ejecutar√°n principalmente _en masa_ y en condiciones de plena competencia a trav√©s de `test()`:

[source,r,cell-code]
----
test()
#> ‚Ñπ Testing regexcite
#> ‚úî | F W  S  OK | Context
#> 
#> ‚†è |          0 | strsplit1                                          
#> ‚úî |          1 | strsplit1
#> 
#> ‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#> [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
#> 
#> üòÄ
----

[TIP]
.RStudio
====
RStudio expone `test()` en el men√∫ _Build_, en el panel _Build_ via _More ++>++ Test package_, y con atajos de teclado Ctrl {plus} Shift {plus} T (Windows & Linux) o Cmd {plus} Shift {plus} T (macOS).
====

Sus pruebas tambi√©n se ejecutan cada vez que `check()` el paquete. De esta manera, b√°sicamente aumentas los controles est√°ndar con algunos propios, que son espec√≠ficos de tu paquete. Es una buena idea utilizar el https://covr.r-lib.org[paquete covr] para realizar un seguimiento de qu√© proporci√≥n del c√≥digo fuente de su paquete se ejerce mediante las pruebas. Se pueden encontrar m√°s detalles en <<sec-testing-design-coverage>>.

== `use++_++package()`

Inevitablemente querr√°s utilizar una funci√≥n de otro paquete en tu propio paquete. Necesitaremos usar m√©todos espec√≠ficos de paquetes para declarar los otros paquetes que necesitamos (es decir, nuestras dependencias) y para usar estos paquetes en los nuestros. Si planea enviar un paquete a CRAN, tenga en cuenta que esto se aplica incluso a funciones en paquetes que considera "`siempre disponibles`", como `stats::median()` o `utils::head()`.

Un dilema com√∫n al utilizar las funciones de expresi√≥n regular de R es la incertidumbre sobre si solicitar `perl = TRUE` o `perl = FALSE`. Y luego, a menudo, pero no siempre, hay otros argumentos que alteran la forma en que se combinan los patrones, como `fixed`, `ignore.case` e `invert`. Puede ser dif√≠cil realizar un seguimiento de qu√© funciones utilizan qu√© argumentos y c√≥mo interact√∫an los argumentos, por lo que muchos usuarios nunca llegan al punto en el que conservan estos detalles sin volver a leer los documentos.

El paquete stringr "`proporciona un conjunto coherente de funciones dise√±adas para hacer que trabajar con cadenas de caracteres sea lo m√°s f√°cil posible`". En particular, stringr usa un sistema de expresi√≥n regular en todas partes (expresiones regulares ICU) y usa la misma interfaz en cada funci√≥n para controlar comportamientos coincidentes, como la distinci√≥n entre may√∫sculas y min√∫sculas. A algunas personas les resulta m√°s f√°cil internalizar y programar esto. Imaginemos que decide que prefiere construir regexcite basado en stringr (y stringi) que en las funciones de expresi√≥n regular de base R.

Primero, declare su intenci√≥n general de utilizar algunas funciones del espacio de nombres stringr con `use++_++package()`:

[source,r,cell-code]
----
use_package("stringr")
#> ‚úî Adding 'stringr' to Imports field in DESCRIPTION
#> ‚Ä¢ Refer to functions with `stringr::fun()`
----

Esto agrega el paquete stringr al campo `Imports` de `DESCRIPTION`. Y eso es todo lo que hace.

Volvamos a visitar `strsplit1()` para hacerlo m√°s parecido a una cadena. Aqu√≠ hay una nueva versi√≥nfootnote:[Recuerde que este ejemplo fue tan inspirador que ahora es una funci√≥n real en el paquete stringr: ++`++stringr::str++_++split++_++1()++`++!]:

[source,r,cell-code]
----
str_split_one <- function(string, pattern, n = Inf) {
  stopifnot(is.character(string), length(string) <= 1)
  if (length(string) == 1) {
    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]
  } else {
    character()
  }
}
----

Tenga en cuenta que nosotros:

* Cambie el nombre de la funci√≥n a `str++_++split++_++one()`, para indicar que es un contenedor alrededor de `stringr::str++_++split()`.
* Adopte los nombres de los argumentos de `stringr::str++_++split()`. Ahora tenemos `string` y `pattern` (y `n`), en lugar de `x` y `split`.
* Introducir un poco de verificaci√≥n de argumentos y manejo de casos extremos. Esto no est√° relacionado con el cambio a stringr y ser√≠a igualmente beneficioso en la versi√≥n construida en `strsplit()`.
* Utilice el formulario `paquete::funci√≥n()` al llamar a `stringr::str++_++split()`. Esto especifica que queremos llamar a la funci√≥n `str++_++split()` desde el espacio de nombres stringr. Hay m√°s de una forma de llamar a una funci√≥n desde otro paquete y la que recomendamos aqu√≠ se explica detalladamente en <<sec-dependencies-in-practice>>.

¬øD√≥nde deber√≠amos escribir esta nueva definici√≥n de funci√≥n? Si queremos seguir la convenci√≥n en la que nombramos el archivo `.R` despu√©s de la funci√≥n que define, ahora necesitamos realizar algunos cambios complicados en los archivos. Debido a que esto ocurre con bastante frecuencia en la vida real, tenemos la funci√≥n `rename++_++files()`, que coreograf√≠a el cambio de nombre de un archivo en `R/` y sus archivos complementarios asociados debajo de `test/`.

[source,r,cell-code]
----
rename_files("strsplit1", "str_split_one")
#> ‚úî Moving 'R/strsplit1.R' to 'R/str_split_one.R'
#> ‚úî Moving 'tests/testthat/test-strsplit1.R' to 'tests/testthat/test-str_split_one.R'
----

Recuerde: el trabajo del nombre del archivo es puramente aspiracional. ¬°A√∫n necesitamos actualizar el contenido de estos archivos!

Aqu√≠ est√°n los contenidos actualizados de `R/str++_++split++_++one.R`. Adem√°s de cambiar la definici√≥n de la funci√≥n, tambi√©n actualizamos el encabezado de roxygen para reflejar los nuevos argumentos e incluir ejemplos que muestren las caracter√≠sticas de stringr.

[source,r,r,cell-code]
----
#' dividir una cadena de caracteres
#'
#' @param string Un vector de caracteres con, como m√°ximo, un elemento.
#' @inheritParams stringr::str_split
#'
#' @return Un vector de caracteres.
#' @export
#'
#' @examples
#' x <- "alfa,bravo,charlie,delta"
#' str_split_one(x, pattern = ",")
#' str_split_one(x, pattern = ",", n = 2)
#'
#' y <- "192.168.0.1"
#' str_split_one(y, pattern = stringr::fixed("."))
str_split_one <- function(string, pattern, n = Inf) {
  stopifnot(is.character(string), length(string) <= 1)
  if (length(string) == 1) {
    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]
  } else {
    character()
  }
}
----

¬°No olvides actualizar tambi√©n el archivo de prueba!

Aqu√≠ est√°n los contenidos actualizados de `tests/testthat/test-str++_++split++_++one.R`. Adem√°s del cambio en el nombre y los argumentos de la funci√≥n, agregamos un par de pruebas m√°s.

[source,r,r,cell-code]
----
test_that("str_split_one() divide una cadena de caracteres", {
  expect_equal(str_split_one("a,b,c", ","), c("a", "b", "c"))
})

test_that("str_split_one() errores si la longitud de entrada > 1", {
  expect_error(str_split_one(c("a,b","c,d"), ","))
})

test_that("str_split_one() expone caracter√≠sticas de stringr::str_split()", {
  expect_equal(str_split_one("a,b,c", ",", n = 2), c("a", "b,c"))
  expect_equal(str_split_one("a.b", stringr::fixed(".")), c("a", "b"))
})
----

Antes de probar el nuevo `str++_++split++_++one()`, necesitamos llamar a `document()`. ¬øPor qu√©? Recuerde que `document()` realiza dos tareas principales:

[arabic]
. Convierte nuestros comentarios de roxygen en documentaci√≥n R adecuada.
. (Re)genera `NAMESPACE`.

El segundo trabajo es especialmente importante aqu√≠, ya que ya no exportaremos `strsplit1()` y ahora exportaremos `str++_++split++_++one()`. No se desanime por la advertencia sobre `"Objects listed as exports, but not present in namespace: strsplit1"`. Eso siempre sucede cuando eliminas algo del espacio de nombres.

[source,r,cell-code]
----
document()
#> ‚Ñπ Updating regexcite documentation
#> ‚Ñπ Loading regexcite
#> Warning: Objects listed as exports, but not present in namespace:
#> ‚Ä¢ strsplit1
#> Writing 'NAMESPACE'
#> Writing 'str_split_one.Rd'
#> Deleting 'strsplit1.Rd'
----

Pruebe la nueva funci√≥n `str++_++split++_++one()` simulando la instalaci√≥n del paquete mediante `load++_++all()`:

[source,r,cell-code]
----
load_all()
#> ‚Ñπ Loading regexcite
str_split_one("a, b, c", pattern = ", ")
#> [1] "a" "b" "c"
----

== `use++_++github()`

Nos has visto haciendo commits durante el proceso de desarrollo de regexcite. Puede ver un historial indicativo en https://github.com/jennybc/regexcite. Nuestro uso del control de versiones y la decisi√≥n de exponer el proceso de desarrollo significa que puede inspeccionar el estado de la fuente de regexcite en cada etapa de desarrollo. Al observar las llamadas diferencias, puede ver exactamente c√≥mo cada funci√≥n auxiliar de devtools modifica los archivos fuente que constituyen el paquete regexcite.

¬øC√≥mo conectar√≠a su paquete regexcite local y su repositorio Git a un repositorio complementario en GitHub? Aqu√≠ hay tres enfoques:

[arabic]
. https://usethis.r-lib.org/reference/use_github.html[`use++_++github()`] es una ayuda que recomendamos a largo plazo. No lo demostraremos aqu√≠ porque requiere cierta configuraci√≥n de credenciales por su parte. Tampoco queremos derribar y reconstruir el paquete p√∫blico de regexcite cada vez que construimos este libro.
. ¬°Primero configura el repositorio de GitHub! Suena contrario a la intuici√≥n, pero la forma m√°s f√°cil de llevar su trabajo a GitHub es iniciarlo all√≠ y luego usar RStudio para comenzar a trabajar en una copia local sincronizada. Este enfoque se describe en los flujos de trabajo de Happy Git https://happygitwithr.com/new-github-first.html[Nuevo proyecto&#44; GitHub primero] y https://happygitwithr.com/existing-github-first.html[Proyecto existente&#44; GitHub primero].
. La l√≠nea de comando Git siempre se puede usar para agregar un repositorio remoto _post hoc_. Esto se describe en el flujo de trabajo de Happy Git https://happygitwithr.com/existing-github-last.html[Proyecto existente&#44; GitHub √∫ltimo].

Cualquiera de estos enfoques conectar√° su proyecto regexcite local a un repositorio de GitHub, p√∫blico o privado, al que puede enviar o extraer usando el cliente Git integrado en RStudio. En <<sec-sw-dev-practices>>, explicamos por qu√© vale la pena incorporar el control de versiones (por ejemplo, Git) y, espec√≠ficamente, el control de versiones alojado (por ejemplo, GitHub) en su proceso de desarrollo de paquetes.

== `use++_++readme++_++rmd()`

Ahora que su paquete est√° en GitHub, el archivo `README.md` es importante. Es la p√°gina de inicio y el tapete de bienvenida del paquete, al menos hasta que decida darle un sitio web (ver <<sec-website>>), agregar una vi√±eta (ver <<sec-vignettes>>) o enviarlo a CRAN (ver <<sec-release>> ).

La funci√≥n `use++_++readme++_++rmd()` inicializa un `README.Rmd` b√°sico y ejecutable listo para que usted pueda editar:

[source,r,cell-code]
----
use_readme_rmd()
#> ‚úî Writing 'README.Rmd'
#> ‚úî Adding '^README\\.Rmd$' to '.Rbuildignore'
#> ‚Ä¢ Update 'README.Rmd' to include installation instructions.
#> ‚úî Writing '.git/hooks/pre-commit'
----

Adem√°s de crear `README.Rmd`, esto agrega algunas l√≠neas a `.Rbuildignore` y crea un enlace de confirmaci√≥n previa de Git para ayudarlo a mantener sincronizados `README.Rmd` y `README.md`.

`README.Rmd` ya tiene secciones que le solicitan que:

* Describe el prop√≥sito del paquete.
* Proporcionar instrucciones de instalaci√≥n. Si se detecta un control remoto de GitHub cuando se llama a `use++_++readme++_++rmd()`, esta secci√≥n est√° completa con instrucciones sobre c√≥mo instalar desde GitHub.
* Muestra un poco de uso..

¬øC√≥mo poblar este esqueleto? Copie material generosamente de `DESCRIPTION` y cualquier prueba o ejemplo formal e informal que tenga. Algo es mejor que nada. Esto es √∫til porque la gente probablemente no instalar√° su paquete ni revisar√° los archivos de ayuda individuales para descubrir c√≥mo usarlo.

Nos gusta escribir el `README` en R Markdown, para que pueda incluir el uso real. La inclusi√≥n de c√≥digo en vivo tambi√©n hace que sea menos probable que su `README` se vuelva obsoleto y no est√© sincronizado con su paquete real.

Para realizar sus propias ediciones, si RStudio a√∫n no lo ha hecho, abra `README.Rmd` para editar. Aseg√∫rese de que muestre alg√∫n uso de `str++_++split++_++one()`.

El `README.Rmd` que utilizamos est√° aqu√≠: https://github.com/jennybc/regexcite/blob/main/README.Rmd[README.Rmd] y esto es lo que contiene:

....
---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

**NOTE: This is a toy package created for expository purposes, for the second edition of [R Packages](https://r-pkgs.org). It is not meant to actually be useful. If you want a package for factor handling, please see [stringr](https://stringr.tidyverse.org), [stringi](https://stringi.gagolewski.com/),
[rex](https://cran.r-project.org/package=rex), and
[rematch2](https://cran.r-project.org/package=rematch2).**

# regexcite

<!-- badges: start -->
<!-- badges: end -->

The goal of regexcite is to make regular expressions more exciting!
It provides convenience functions to make some common tasks with string manipulation and regular expressions a bit easier.

## Installation

You can install the development version of regexcite from [GitHub](https://github.com/) with:
      
``` r
# install.packages("devtools")
devtools::install_github("jennybc/regexcite")
```

## Usage

A fairly common task when dealing with strings is the need to split a single string into many parts.
This is what `base::strplit()` and `stringr::str_split()` do.

```{r}
(x <- "alfa,bravo,charlie,delta")
strsplit(x, split = ",")
stringr::str_split(x, pattern = ",")
```

Notice how the return value is a **list** of length one, where the first element holds the character vector of parts.
Often the shape of this output is inconvenient, i.e. we want the un-listed version.

That's exactly what `regexcite::str_split_one()` does.

```{r}
library(regexcite)

str_split_one(x, pattern = ",")
```

Use `str_split_one()` when the input is known to be a single string.
For safety, it will error if its input has length greater than one.

`str_split_one()` is built on `stringr::str_split()`, so you can use its `n` argument and stringr's general interface for describing the `pattern` to be matched.

```{r}
str_split_one(x, pattern = ",", n = 2)

y <- "192.168.0.1"
str_split_one(y, pattern = stringr::fixed("."))
```
....

¬°No olvides renderizarlo para crear `README.md`! El enlace de confirmaci√≥n previa deber√≠a recordarle si intenta confirmar `README.Rmd`, pero no `README.md`, y tambi√©n cuando `README.md` parece estar desactualizado.

La mejor manera de renderizar `README.Rmd` es con `build++_++readme()`, porque se encarga de renderizar con la versi√≥n m√°s actual de su paquete, es decir, instala una copia temporal de la fuente actual.

[source,r,cell-code]
----
build_readme()
#> ‚Ñπ Installing regexcite in temporary library
#> ‚Ñπ Building '/tmp/RtmpJR4gjQ/regexcite/README.Rmd'
----

Puede ver el `README.md` renderizado simplemente https://github.com/jennybc/regexcite#readme[visitando regexcite en GitHub].

Finalmente, no olvides hacer una √∫ltima confirmaci√≥n. Y realiza un push, si est√°s usando GitHub.

== El √∫ltimo: `check()` e `install()`

Ejecutemos `check()` nuevamente para asegurarnos de que todo est√© bien.

[source,r,cell-code]
----
check()
----

....
‚îÄ‚îÄ R CMD check results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ regexcite 0.0.0.9000 ‚îÄ‚îÄ‚îÄ‚îÄ
Duration: 8.2s

0 errors ‚úî | 0 warnings ‚úî | 0 notes ‚úî
....

regexcite No debe tener errores, advertencias o notas. Este ser√≠a un buen momento para reconstruirlo e instalarlo correctamente. ¬°Y celebra!

[source,r,cell-code]
----
install()
----

....
‚îÄ‚îÄ R CMD build ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
* checking for file ‚Äò/tmp/RtmpJR4gjQ/regexcite/DESCRIPTION‚Äô ... OK
* preparing ‚Äòregexcite‚Äô:
* checking DESCRIPTION meta-information ... OK
* checking for LF line-endings in source and make files and shell scripts
* checking for empty or unneeded directories
Removed empty directory ‚Äòregexcite/tests/testthat/_snaps‚Äô
* building ‚Äòregexcite_0.0.0.9000.tar.gz‚Äô
Running /opt/R/4.4.0/lib/R/bin/R CMD INSTALL \
  /tmp/RtmpJR4gjQ/regexcite_0.0.0.9000.tar.gz --install-tests 
* installing to library ‚Äò/home/runner/work/r-pkgses/r-pkgses/renv/library/linux-ubuntu-noble/R-4.4/x86_64-pc-linux-gnu‚Äô
* installing *source* package ‚Äòregexcite‚Äô ...
** using staged installation
** R
** tests
** byte-compile and prepare package for lazy loading
** help
*** installing help indices
** building package indices
** testing if installed package can be loaded from temporary location
** testing if installed package can be loaded from final location
** testing if installed package keeps a record of temporary installation path
* DONE (regexcite)
....

No dude en visitar el https://github.com/jennybc/regexcite[paquete regexcite] en GitHub, que aparece exactamente como se desarroll√≥ aqu√≠. El historial de commits refleja cada paso individual, as√≠ que utilice las diferencias para ver la adici√≥n y modificaci√≥n de archivos a medida que evoluciona el paquete. El resto de este libro detalla cada paso que has visto aqu√≠ y mucho m√°s.

== Revisi√≥n

Este cap√≠tulo est√° destinado a darle una idea del flujo de trabajo t√≠pico de desarrollo de paquetes, resumido como un diagrama en <<fig-package-dev-workflow>>. Todo lo que ve aqu√≠ se ha abordado en este cap√≠tulo, con la excepci√≥n de las Acciones de GitHub, sobre las cuales aprender√° m√°s en <<sec-sw-dev-practices-gha>>.

.El flujo de trabajo de desarrollo del paquete devtools.
[#fig-package-dev-workflow]
image::diagrams/workflow.png[diagrams/workflow]

Aqu√≠ hay una revisi√≥n de las funciones clave que ha visto en este cap√≠tulo, organizadas aproximadamente por su papel en el proceso de desarrollo.

Estas funciones configuran partes del paquete y normalmente se llaman una vez por paquete:

* `create++_++package()`
* `use++_++git()`
* `use++_++mit++_++license()`
* `use++_++testthat()`
* `use++_++github()`
* `use++_++readme++_++rmd()`

Llamar√° a estas funciones de forma regular, a medida que agregue funciones y pruebas o asuma dependencias:

* `use++_++r()`
* `use++_++test()`
* `use++_++package()`

Llamar√° a estas funciones varias veces por d√≠a o por hora, durante el desarrollo:

* `load++_++all()`
* `document()`
* `test()`
* `check()`
